{
	"info": {
		"_postman_id": "9f0f7d03-fed9-427c-a687-0971d64bd476",
		"name": "Assessment 1 Test Suite",
		"description": "Collection of endpoints to test the APIs the students create for their second assessment.",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "User",
			"item": [
				{
					"name": "Get Empty Users",
					"item": [
						{
							"name": "Get All Users Empty",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const userSchema = pm.environment.get('userSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of user dto\\'s',",
											"    items: { $ref: userSchema }",
											"}",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Returns an empty array', () => {",
											"    pm.expect(pm.response.json().length).to.eql(0)",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users"
									]
								},
								"description": "Initially no users have been created so this method should return an empty array.\n\nStatus Expected: success\nExpected Response: [ ] (an empty array)"
							},
							"response": []
						},
						{
							"name": "Get NonExisting User",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status error', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@doesNotExist",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@doesNotExist"
									]
								},
								"description": "Attempts to get a user that doesn't exist in the database (at this point in testing). Should return an error code with no response body.\n\nExpected Status: error (400s && 500s) (Preferably a 404 Not Found!)\nExpected Body: none"
							},
							"response": []
						}
					],
					"description": "Test getter endpoints before actually creating any users."
				},
				{
					"name": "Create New Users",
					"item": [
						{
							"name": "Create FirstUser Fail (No Email)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success (password required)', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n    \"username\": \"{{firstUser}}\",\n    \"password\": \"{{password}}\"\n  },\n  \"profile\": {\n    \"firstName\": \"{{firstUserFirstName}}\",\n    \"lastName\": \"{{firstUserLastName}}\",\n    \"phone\": \"{{firstUserPhone}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users"
									]
								},
								"description": "If a user tries to create a user without a password, an error code of some kind should be sent in leu of a response.\n\nExpected Status: An \"error\" status code. Somewhere in the 400s or 500s.\nNo Response Body expected. If the student adds more advanced error handling though, we should not penalize them."
							},
							"response": []
						},
						{
							"name": "Create FirstUser Fail (No Password)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success (password required)', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n    \"username\": \"{{firstUser}}\"\n  },\n  \"profile\": {\n  \t\"email\": \"{{firstUserEmail}}\",\n    \"firstName\": \"{{firstUserFirstName}}\",\n    \"lastName\": \"{{firstUserLastName}}\",\n    \"phone\": \"{{firstUserPhone}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users"
									]
								},
								"description": "If a user tries to create a user without a password, an error code of some kind should be sent in leu of a response.\n\nExpected Status: An \"error\" status code. Somewhere in the 400s or 500s.\nNo Response Body expected. If the student adds more advanced error handling though, we should not penalize them."
							},
							"response": []
						},
						{
							"name": "Create FirstUser Fail (No Username)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success (username required)', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n    \"password\": \"{{password}}\"\n  },\n  \"profile\": {\n  \t\"email\": \"{{firstUserEmail}}\",\n    \"firstName\": \"{{firstUserFirstName}}\",\n    \"lastName\": \"{{firstUserLastName}}\",\n    \"phone\": \"{{firstUserPhone}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users"
									]
								},
								"description": "If a user tries to create a user without a username, an error code of some kind should be sent in leu of a response.\n\nExpected Status: An \"error\" status code. Somewhere in the 400s or 500s.\nNo Response Body expected. If the student adds more advanced error handling though, we should not penalize them."
							},
							"response": []
						},
						{
							"name": "Create FirstUser",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('userSchema')",
											"",
											"if (pm.response.code >= 200 && pm.response.code < 300) {",
											"    pm.test('Success status', () => {",
											"        pm.response.to.be.success",
											"    })",
											"    ",
											"    pm.test('Schema is valid', () => {",
											"      pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"    })",
											"    ",
											"    pm.test('Username was set correctly', () => {",
											"        pm.expect(pm.response.json().username).to.eql(pm.environment.get('firstUser'))",
											"    })",
											"    ",
											"    pm.test('Joined date was set', () => {",
											"        const joined = pm.response.json().joined",
											"        pm.expect(joined).to.not.eql(null)",
											"        pm.expect(joined).to.not.eql(undefined)",
											"        pm.environment.set('firstUserJoined', joined)",
											"    })",
											"    ",
											"    pm.test('Profile was set correctly', () => {",
											"        const profile = pm.response.json().profile",
											"        pm.expect(profile.firstName).to.eql(pm.environment.get('firstUserFirstName'))",
											"        pm.expect(profile.lastName).to.eql(pm.environment.get('firstUserLastName'))",
											"        pm.expect(profile.email).to.eql(pm.environment.get('firstUserEmail'))",
											"        pm.expect(profile.phone).to.eql(pm.environment.get('firstUserPhone'))",
											"    })",
											"} else {",
											"    pm.test('Error status', () => {",
											"        pm.response.to.not.be.info",
											"        pm.response.to.not.be.success",
											"    })",
											"    ",
											"    pm.test('Should not be internal server error', () => {",
											"        pm.response.to.not.be.serverError",
											"    })",
											"",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n  \t\"username\": \"{{firstUser}}\",\n    \"password\": \"{{password}}\"\n  },\n  \"profile\": {\n    \"email\": \"{{firstUserEmail}}\",\n    \"firstName\": \"{{firstUserFirstName}}\",\n    \"lastName\": \"{{firstUserLastName}}\",\n    \"phone\": \"{{firstUserPhone}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users"
									]
								},
								"description": "If a user tries to create a user without a username, an error code of some kind should be sent in leu of a response.\n\nExpected Status: An \"error\" status code. Somewhere in the 400s or 500s.\nNo Response Body expected. If the student adds more advanced error handling though, we should not penalize them."
							},
							"response": []
						},
						{
							"name": "Create FirstUser Again",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Error status', () => {",
											"    pm.response.to.not.be.info",
											"    pm.response.to.not.be.success",
											"})",
											"",
											"pm.test('Should not be internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n    \"username\": \"{{firstUser}}\",\n    \"password\": \"{{password}}\"\n  },\n  \"profile\": {\n    \"email\": \"{{firstUserEmail}}\",\n    \"firstName\": \"{{firstUserFirstName}}\",\n    \"lastName\": \"{{firstUserLastName}}\",\n    \"phone\": \"{{firstUserPhone}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users"
									]
								},
								"description": "If a user tries to create a user without a username, an error code of some kind should be sent in leu of a response.\n\nExpected Status: An \"error\" status code. Somewhere in the 400s or 500s.\nNo Response Body expected. If the student adds more advanced error handling though, we should not penalize them."
							},
							"response": []
						},
						{
							"name": "Create SecondUser Fail (No Credentials)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success (credentials required)', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"profile\": {\n    \"email\": \"{{secondUserEmail}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users"
									]
								},
								"description": "If a user tries to create a user without any credentials, an error code of some kind should be sent in leu of a response.\n\nExpected Status: An \"error\" status code. Somewhere in the 400s or 500s.\nNo Response Body expected. If the student adds more advanced error handling though, we should not penalize them."
							},
							"response": []
						},
						{
							"name": "Create SecondUser Fail (Empty Request)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success (request is empty)', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n}"
								},
								"url": {
									"raw": "localhost:8080/users",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users"
									]
								},
								"description": "If a user tries to create a user with an empty request, an error code of some kind should be sent in leu of a response.\n\nExpected Status: An \"error\" status code. Somewhere in the 400s or 500s.\nNo Response Body expected. If the student adds more advanced error handling though, we should not penalize them."
							},
							"response": []
						},
						{
							"name": "Create SecondUser Fail (No Profile)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success (password required)', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n    \"username\": \"{{secondUser}}\",\n    \"password\": \"{{password}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users"
									]
								},
								"description": "If a user tries to create a user with no profile at all, an error code of some kind should be sent in leu of a response.\n\nExpected Status: An \"error\" status code. Somewhere in the 400s or 500s.\nNo Response Body expected. If the student adds more advanced error handling though, we should not penalize them."
							},
							"response": []
						},
						{
							"name": "Create SecondUser",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('userSchema')",
											"",
											"pm.test('Success status', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Username was set correctly', () => {",
											"    pm.expect(pm.response.json().username).to.eql(pm.environment.get('secondUser'))",
											"})",
											"",
											"pm.test('Joined date was set', () => {",
											"    const joined = pm.response.json().joined",
											"    pm.expect(joined).to.not.eql(null)",
											"    pm.expect(joined).to.not.eql(undefined)",
											"    pm.environment.set('secondUserJoined', joined)",
											"})",
											"",
											"pm.test('Profile was set correctly', () => {",
											"    const profile = pm.response.json().profile",
											"    pm.expect(profile.firstName).to.eql(null)",
											"    pm.expect(profile.lastName).to.eql(null)",
											"    pm.expect(profile.email).to.eql(pm.environment.get('secondUserEmail'))",
											"    pm.expect(profile.phone).to.eql(null)",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n  \t\"username\": \"{{secondUser}}\",\n  \t\"password\": \"{{password}}\"\n  },\n  \"profile\": {\n    \"email\": \"{{secondUserEmail}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users"
									]
								},
								"description": "If a user tries to create a user with an empty request, an error code of some kind should be sent in leu of a response.\n\nExpected Status: An \"error\" status code. Somewhere in the 400s or 500s.\nNo Response Body expected. If the student adds more advanced error handling though, we should not penalize them."
							},
							"response": []
						},
						{
							"name": "Create SecondUser Again",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Error status', () => {",
											"    pm.response.to.not.be.info",
											"    pm.response.to.not.be.success",
											"})",
											"",
											"pm.test('Should not be internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n    \"username\": \"{{secondUser}}\",\n    \"password\": \"{{password}}\"\n  },\n  \"profile\": {\n    \"email\": \"{{secondUserEmail}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users"
									]
								},
								"description": "If a user tries to create a user with an empty request, an error code of some kind should be sent in leu of a response.\n\nExpected Status: An \"error\" status code. Somewhere in the 400s or 500s.\nNo Response Body expected. If the student adds more advanced error handling though, we should not penalize them."
							},
							"response": []
						}
					],
					"description": "Tests for creating new users."
				},
				{
					"name": "Update User",
					"item": [
						{
							"name": "Update NonExisting User",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status error', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "PATCH",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n    \"username\": \"doesn't matter\",\n    \"password\": \"probably shouldn't be one\"\n  },\n  \"profile\": {\n    \"email\": \"test@test.com\",\n    \"firstName\": \"filling this in for funzies\",\n    \"lastName\": \"literally doesn't matter\",\n    \"phone\": \"not going to work!\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@nonExisting",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@nonExisting"
									]
								},
								"description": "Attempts to update a user that does not exist (at least at this point in testing). Should return an error with no response body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "Update SecondUser Fail (No Username)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status error', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "PATCH",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n    \"password\": \"{{password}}\"\n  },\n  \"profile\": {\n    \"email\": \"{{secondUserEmail}}\",\n    \"firstName\": \"{{secondUserFirstName}}\",\n    \"lastName\": \"{{secondUserLastName}}\",\n    \"phone\": \"{{secondUserPhone}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}"
									]
								},
								"description": "Attempts to update the secondUser with no username provided. Should return an error and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "Update SecondUser Fail (No Password)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status error', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "PATCH",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n  \t\"username\": \"{{secondUser}}\"\n  },\n  \"profile\": {\n    \"email\": \"{{secondUserEmail}}\",\n    \"firstName\": \"{{secondUserFirstName}}\",\n    \"lastName\": \"{{secondUserLastName}}\",\n    \"phone\": \"{{secondUserPhone}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}"
									]
								},
								"description": "Attempts to update the secondUser with no password provided. Should return an error and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "Update SecondUser Fail (No Credentials)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status error', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "PATCH",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"profile\": {\n    \"email\": \"{{secondUserEmail}}\",\n    \"firstName\": \"{{secondUserFirstName}}\",\n    \"lastName\": \"{{secondUserLastName}}\",\n    \"phone\": \"{{secondUserPhone}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}"
									]
								},
								"description": "Updates the profile of a user with the given username. If no such user exists, the user is deleted, or the provided credentials do not match the user, an error should be sent in lieu of a response. In the case of a successful update, the returned user should contain the updated data.\n\nRequest:\n{\n  \"credentials\": {\n    \"username\": \"{username}\",\n    \"password\": \"{password}\"\n  },\n  \"profile\": {\n    \"firstName\": \"{firstName}\",\n    \"lastName\": \"{lastName}\",\n    \"email\": \"{email}\",\n    \"phone\": \"{phoneNumber}\"\n  }\n}\n\nResponse:\n{\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n        \"firstName\": \"{firstName}\",\n        \"lastName\": \"{lastName}\",\n        \"email\": \"{email}\",\n        \"phone\": \"{phoneNumber}\"\n    }\n}"
							},
							"response": []
						},
						{
							"name": "Update SecondUser Fail (No Profile)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status error', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "PATCH",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n    \"username\": \"{{secondUser}}\",\n    \"password\": \"{{password}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}"
									]
								},
								"description": "Updates the profile of a user with the given username. If no such user exists, the user is deleted, or the provided credentials do not match the user, an error should be sent in lieu of a response. In the case of a successful update, the returned user should contain the updated data.\n\nRequest:\n{\n  \"credentials\": {\n    \"username\": \"{username}\",\n    \"password\": \"{password}\"\n  },\n  \"profile\": {\n    \"firstName\": \"{firstName}\",\n    \"lastName\": \"{lastName}\",\n    \"email\": \"{email}\",\n    \"phone\": \"{phoneNumber}\"\n  }\n}\n\nResponse:\n{\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n        \"firstName\": \"{firstName}\",\n        \"lastName\": \"{lastName}\",\n        \"email\": \"{email}\",\n        \"phone\": \"{phoneNumber}\"\n    }\n}"
							},
							"response": []
						},
						{
							"name": "Update SecondUser First Empty",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('userSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Username matches', () => {",
											"    pm.expect(pm.response.json().username).to.eql(pm.environment.get('secondUser'))",
											"})",
											"",
											"pm.test('Joined date has not been modified', () => {",
											"    pm.expect(new Date(pm.response.json().joined)).to.eql(new Date(pm.environment.get('secondUserJoined')))",
											"})",
											"",
											"",
											"pm.test('Profile was set correctly', () => {",
											"    const profile = pm.response.json().profile",
											"    pm.expect(profile.firstName).to.eql(null)",
											"    pm.expect(profile.lastName).to.eql(null)",
											"    pm.expect(profile.email).to.eql(pm.environment.get('secondUserEmail'))",
											"    pm.expect(profile.phone).to.eql(null)",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "PATCH",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n    \"username\": \"{{secondUser}}\",\n    \"password\": \"{{password}}\"\n  },\n  \"profile\": {\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}"
									]
								},
								"description": "Updates the profile of a user with the given username. If no such user exists, the user is deleted, or the provided credentials do not match the user, an error should be sent in lieu of a response. In the case of a successful update, the returned user should contain the updated data.\n\nRequest:\n{\n  \"credentials\": {\n    \"username\": \"{username}\",\n    \"password\": \"{password}\"\n  },\n  \"profile\": {\n    \"firstName\": \"{firstName}\",\n    \"lastName\": \"{lastName}\",\n    \"email\": \"{email}\",\n    \"phone\": \"{phoneNumber}\"\n  }\n}\n\nResponse:\n{\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n        \"firstName\": \"{firstName}\",\n        \"lastName\": \"{lastName}\",\n        \"email\": \"{email}\",\n        \"phone\": \"{phoneNumber}\"\n    }\n}"
							},
							"response": []
						},
						{
							"name": "Update SecondUser",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('userSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Username matches', () => {",
											"    pm.expect(pm.response.json().username).to.eql(pm.environment.get('secondUser'))",
											"})",
											"",
											"pm.test('Joined date has not been modified', () => {",
											"    pm.expect(new Date(pm.response.json().joined)).to.eql(new Date(pm.environment.get('secondUserJoined')))",
											"})",
											"",
											"pm.test('Profile is correct', () => {",
											"    const profile = pm.response.json().profile",
											"    pm.expect(profile.firstName).to.eql(pm.environment.get('secondUserFirstName'))",
											"    pm.expect(profile.lastName).to.eql(pm.environment.get('secondUserLastName'))",
											"    pm.expect(profile.email).to.eql(pm.environment.get('secondUserEmail'))",
											"    pm.expect(profile.phone).to.eql(pm.environment.get('secondUserPhone'))",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "PATCH",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n    \"username\": \"{{secondUser}}\",\n    \"password\": \"{{password}}\"\n  },\n  \"profile\": {\n    \"email\": \"{{secondUserEmail}}\",\n    \"firstName\": \"{{secondUserFirstName}}\",\n    \"lastName\": \"{{secondUserLastName}}\",\n    \"phone\": \"{{secondUserPhone}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}"
									]
								},
								"description": "Updates the profile of a user with the given username. If no such user exists, the user is deleted, or the provided credentials do not match the user, an error should be sent in lieu of a response. In the case of a successful update, the returned user should contain the updated data.\n\nRequest:\n{\n  \"credentials\": {\n    \"username\": \"{username}\",\n    \"password\": \"{password}\"\n  },\n  \"profile\": {\n    \"firstName\": \"{firstName}\",\n    \"lastName\": \"{lastName}\",\n    \"email\": \"{email}\",\n    \"phone\": \"{phoneNumber}\"\n  }\n}\n\nResponse:\n{\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n        \"firstName\": \"{firstName}\",\n        \"lastName\": \"{lastName}\",\n        \"email\": \"{email}\",\n        \"phone\": \"{phoneNumber}\"\n    }\n}"
							},
							"response": []
						},
						{
							"name": "Update SecondUser Second Empty",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('userSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Username matches', () => {",
											"    pm.expect(pm.response.json().username).to.eql(pm.environment.get('secondUser'))",
											"})",
											"",
											"pm.test('Joined date has not been modified', () => {",
											"    pm.expect(new Date(pm.response.json().joined)).to.eql(new Date(pm.environment.get('secondUserJoined')))",
											"})",
											"",
											"",
											"pm.test('Profile was set correctly', () => {",
											"    const profile = pm.response.json().profile",
											"    pm.expect(profile.firstName).to.eql(pm.environment.get('secondUserFirstName'))",
											"    pm.expect(profile.lastName).to.eql(pm.environment.get('secondUserLastName'))",
											"    pm.expect(profile.email).to.eql(pm.environment.get('secondUserEmail'))",
											"    pm.expect(profile.phone).to.eql(pm.environment.get('secondUserPhone'))",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "PATCH",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n    \"username\": \"{{secondUser}}\",\n    \"password\": \"{{password}}\"\n  },\n  \"profile\": {\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}"
									]
								},
								"description": "Updates the profile of a user with the given username. If no such user exists, the user is deleted, or the provided credentials do not match the user, an error should be sent in lieu of a response. In the case of a successful update, the returned user should contain the updated data.\n\nRequest:\n{\n  \"credentials\": {\n    \"username\": \"{username}\",\n    \"password\": \"{password}\"\n  },\n  \"profile\": {\n    \"firstName\": \"{firstName}\",\n    \"lastName\": \"{lastName}\",\n    \"email\": \"{email}\",\n    \"phone\": \"{phoneNumber}\"\n  }\n}\n\nResponse:\n{\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n        \"firstName\": \"{firstName}\",\n        \"lastName\": \"{lastName}\",\n        \"email\": \"{email}\",\n        \"phone\": \"{phoneNumber}\"\n    }\n}"
							},
							"response": []
						}
					],
					"description": "Tests for updating a user's information."
				},
				{
					"name": "Get Existing Users",
					"item": [
						{
							"name": "Get All Users",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const userSchema = pm.environment.get('userSchema')",
											"",
											"const schema = {",
											"    'type': 'array',",
											"    'description': 'An array of user dto\\'s',",
											"    'items': { $ref: userSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Returns an array with two users', () => {",
											"    pm.expect(pm.response.json().length).to.eql(2)",
											"})",
											"",
											"if (pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const users = pm.response.json().map(user => user.username)",
											"    ",
											"    pm.test('Contains the firstUser', () => {",
											"        pm.expect(users).to.include(pm.environment.get('firstUser'))",
											"    })",
											"    ",
											"    pm.test('Contains the secondUser', () => {",
											"        pm.expect(users).to.include(pm.environment.get('secondUser'))",
											"    })",
											"}",
											"",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users"
									]
								},
								"description": "Initially no users have been created so this method should return an empty array.\n\nStatus Expected: success\nExpected Response: [ ] (an empty array)"
							},
							"response": []
						},
						{
							"name": "Get FirstUser",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('userSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Username is correct', () => {",
											"    pm.expect(pm.response.json().username).to.eql(pm.environment.get('firstUser'))",
											"})",
											"",
											"pm.test('Joined has not been modified', () => {",
											"    pm.expect(new Date(pm.response.json().joined)).to.eql(new Date(pm.environment.get('firstUserJoined')))",
											"})",
											"",
											"pm.test('Profile is correct', () => {",
											"    const profile = pm.response.json().profile",
											"    pm.expect(profile.firstName).to.eql(pm.environment.get('firstUserFirstName'))",
											"    pm.expect(profile.lastName).to.eql(pm.environment.get('firstUserLastName'))",
											"    pm.expect(profile.email).to.eql(pm.environment.get('firstUserEmail'))",
											"    pm.expect(profile.phone).to.eql(pm.environment.get('firstUserPhone'))",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}"
									]
								},
								"description": "Initially no users have been created so this method should return an empty array.\n\nStatus Expected: success\nExpected Response: [ ] (an empty array)"
							},
							"response": []
						},
						{
							"name": "Get SecondUser",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('userSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Username is correct', () => {",
											"    pm.expect(pm.response.json().username).to.eql(pm.environment.get('secondUser'))",
											"})",
											"",
											"pm.test('Joined has not been modified', () => {",
											"    pm.expect(new Date(pm.response.json().joined)).to.eql(new Date(pm.environment.get('secondUserJoined')))",
											"})",
											"",
											"pm.test('Profile is correct', () => {",
											"    const profile = pm.response.json().profile",
											"    pm.expect(profile.firstName).to.eql(pm.environment.get('secondUserFirstName'))",
											"    pm.expect(profile.lastName).to.eql(pm.environment.get('secondUserLastName'))",
											"    pm.expect(profile.email).to.eql(pm.environment.get('secondUserEmail'))",
											"    pm.expect(profile.phone).to.eql(pm.environment.get('secondUserPhone'))",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}"
									]
								},
								"description": "Initially no users have been created so this method should return an empty array.\n\nStatus Expected: success\nExpected Response: [ ] (an empty array)"
							},
							"response": []
						}
					],
					"description": "Tests for retrieving users from the database."
				},
				{
					"name": "Follow and Unfollow",
					"item": [
						{
							"name": "Get Random Followers",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Status should not be internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@random/followers",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@random",
										"followers"
									]
								},
								"description": "Retrieves the followers of the user with the given username. Only active users should be included in the response. If no active user with the given username exists, an error should be sent in lieu of a response.\n\n#### Response\n```\n[ // Array of Users\n\t{\n\t\t\"username\": \"string\",\n\t\t\"profile\": {\n\t\t\t\"firstName\"?: \"string\",\n\t\t\t\"lastName\"?: \"string\",\n\t\t\t\"email\": \"string\",\n\t\t\t\"phone\"?: \"string\"\n\t\t},\n\t\t\"joined\": timestamp\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "Get Random Following",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Status should not be internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@random/following",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@random",
										"following"
									]
								},
								"description": "Retrieves the followers of the user with the given username. Only active users should be included in the response. If no active user with the given username exists, an error should be sent in lieu of a response.\n\n#### Response\n```\n[ // Array of Users\n\t{\n\t\t\"username\": \"string\",\n\t\t\"profile\": {\n\t\t\t\"firstName\"?: \"string\",\n\t\t\t\"lastName\"?: \"string\",\n\t\t\t\"email\": \"string\",\n\t\t\t\"phone\"?: \"string\"\n\t\t},\n\t\t\"joined\": timestamp\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "FirstUser Follow SecondUser Fail (No Credentials)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}/follow",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}",
										"follow"
									]
								},
								"description": "Attempts to follow the secondUser without providing the credentials of the firstUser. Should return an error status and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "FirstUser Follow SecondUser Fail (No Password)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"username\": \"{{firstUser}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}/follow",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}",
										"follow"
									]
								},
								"description": "Attempts to follow the secondUser without providing the password of the firstUser. Should return an error status and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "FirstUser Follow SecondUser Fail (No Username)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}/follow",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}",
										"follow"
									]
								},
								"description": "Attempts to follow the secondUser without providing the username of the firstUser. Should return an error status and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "FirstUser Follow SecondUser",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Should be success', () => {",
											"    pm.response.to.be.success",
											"})",
											""
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"username\": \"{{firstUser}}\",\n  \"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}/follow",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}",
										"follow"
									]
								},
								"description": "Attempts to follow the secondUser without providing the username of the firstUser. Should return an error status and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "FirstUser Follow SecondUser Again",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status error', () => {",
											"    pm.response.to.not.be.success",
											"})",
											"",
											"pm.test('Should not be internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n\t  \"username\": \"{{firstUser}}\",\n\t  \"password\": \"{{password}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}/follow",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}",
										"follow"
									]
								},
								"description": "Attempts to follow the secondUser without providing the username of the firstUser. Should return an error status and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "Get SecondUser Followers",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const userSchema = pm.environment.get('userSchema')",
											"",
											"const schema = {",
											"    'type': 'array',",
											"    'description': 'An array of user dto\\'s',",
											"    'items': { $ref: userSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Array contains only 1 user', () => {",
											"    pm.expect(pm.response.json().length).to.eql(1)",
											"})",
											"",
											"if (pm.response.code === 200 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const users = pm.response.json().map(user => user.username)",
											"    ",
											"    pm.test('Contains the firstUser', () => {",
											"        pm.expect(users).to.include(pm.environment.get('firstUser'))",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}/followers",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}",
										"followers"
									]
								},
								"description": "Retrieves the followers of the user with the given username. Only active users should be included in the response. If no active user with the given username exists, an error should be sent in lieu of a response.\n\n#### Response\n```\n[ // Array of Users\n\t{\n\t\t\"username\": \"string\",\n\t\t\"profile\": {\n\t\t\t\"firstName\"?: \"string\",\n\t\t\t\"lastName\"?: \"string\",\n\t\t\t\"email\": \"string\",\n\t\t\t\"phone\"?: \"string\"\n\t\t},\n\t\t\"joined\": timestamp\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "Get FirstUser Following",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const userSchema = pm.environment.get('userSchema')",
											"",
											"const schema = {",
											"    'type': 'array',",
											"    'description': 'An array of user dto\\'s',",
											"    'items': { $ref: userSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Array contains only 1 user', () => {",
											"    pm.expect(pm.response.json().length).to.eql(1)",
											"})",
											"",
											"if (pm.response.code === 200 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const users = pm.response.json().map(user => user.username)",
											"    ",
											"    pm.test('Contains the secondUser', () => {",
											"        pm.expect(users).to.include(pm.environment.get('secondUser'))",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}/following",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}",
										"following"
									]
								},
								"description": "Retrieves the followers of the user with the given username. Only active users should be included in the response. If no active user with the given username exists, an error should be sent in lieu of a response.\n\n#### Response\n```\n[ // Array of Users\n\t{\n\t\t\"username\": \"string\",\n\t\t\"profile\": {\n\t\t\t\"firstName\"?: \"string\",\n\t\t\t\"lastName\"?: \"string\",\n\t\t\t\"email\": \"string\",\n\t\t\t\"phone\"?: \"string\"\n\t\t},\n\t\t\"joined\": timestamp\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "SecondUser Follow FirstUser",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Should be success', () => {",
											"    pm.response.to.be.success",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"username\": \"{{secondUser}}\",\n  \"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}/follow",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}",
										"follow"
									]
								},
								"description": "Attempts to follow the secondUser without providing the username of the firstUser. Should return an error status and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "SecondUser Follow FirstUser Again",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status error', () => {",
											"    pm.response.to.not.be.success",
											"})",
											"",
											"pm.test('Should not be internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n\t  \"username\": \"{{secondUser}}\",\n\t  \"password\": \"{{password}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}/follow",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}",
										"follow"
									]
								},
								"description": "Attempts to follow the secondUser without providing the username of the firstUser. Should return an error status and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "Get FirstUser Followers",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const userSchema = pm.environment.get('userSchema')",
											"",
											"const schema = {",
											"    'type': 'array',",
											"    'description': 'An array of user dto\\'s',",
											"    'items': { $ref: userSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Array contains only 1 user', () => {",
											"    pm.expect(pm.response.json().length).to.eql(1)",
											"})",
											"",
											"if (pm.response.code === 200 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const users = pm.response.json().map(user => user.username)",
											"    ",
											"    pm.test('Contains the secondUser', () => {",
											"        pm.expect(users).to.include(pm.environment.get('secondUser'))",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}/followers",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}",
										"followers"
									]
								},
								"description": "Retrieves the followers of the user with the given username. Only active users should be included in the response. If no active user with the given username exists, an error should be sent in lieu of a response.\n\n#### Response\n```\n[ // Array of Users\n\t{\n\t\t\"username\": \"string\",\n\t\t\"profile\": {\n\t\t\t\"firstName\"?: \"string\",\n\t\t\t\"lastName\"?: \"string\",\n\t\t\t\"email\": \"string\",\n\t\t\t\"phone\"?: \"string\"\n\t\t},\n\t\t\"joined\": timestamp\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "Get SecondUser Following",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const userSchema = pm.environment.get('userSchema')",
											"",
											"const schema = {",
											"    'type': 'array',",
											"    'description': 'An array of user dto\\'s',",
											"    'items': { $ref: userSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Array contains only 1 user', () => {",
											"    pm.expect(pm.response.json().length).to.eql(1)",
											"})",
											"",
											"pm.test('Contains the firstUser', () => {",
											"    const users = pm.response.json().map(user => user.username)",
											"    pm.expect(users).to.include(pm.environment.get('firstUser'))",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}/following",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}",
										"following"
									]
								},
								"description": "Retrieves the followers of the user with the given username. Only active users should be included in the response. If no active user with the given username exists, an error should be sent in lieu of a response.\n\n#### Response\n```\n[ // Array of Users\n\t{\n\t\t\"username\": \"string\",\n\t\t\"profile\": {\n\t\t\t\"firstName\"?: \"string\",\n\t\t\t\"lastName\"?: \"string\",\n\t\t\t\"email\": \"string\",\n\t\t\t\"phone\"?: \"string\"\n\t\t},\n\t\t\"joined\": timestamp\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "SecondUser Unfollow DoesNotExist",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"username\": \"{{secondUser}}\",\n  \"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@doesNotExist/unfollow",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@doesNotExist",
										"unfollow"
									]
								},
								"description": "Attempts to unfollow a non-existent user. Should return an error status and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "SecondUser Unfollow FirstUser Fail (No Credentials)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}/unfollow",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}",
										"unfollow"
									]
								},
								"description": "Attempts to unfollow the firstUser without providing the credentials of the secondUser. Should return an error status and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "SecondUser Unfollow FirstUser Fail (No Password)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"username\": \"{{secondUser}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}/unfollow",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}",
										"unfollow"
									]
								},
								"description": "Attempts to unfollow the firstUser without providing the password of the secondUser. Should return an error status and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "SecondUser Unfollow FirstUser Fail (No Username)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status client error', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}/unfollow",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}",
										"unfollow"
									]
								},
								"description": "Attempts to unfollow the firstUser without providing the username of the secondUser. Should return an error status and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "SecondUser Unfollow FirstUser",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Should be success', () => {",
											"    pm.response.to.be.success",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \t\"username\": \"{{secondUser}}\",\n  \t\"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}/unfollow",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}",
										"unfollow"
									]
								},
								"description": "Attempts to unfollow the firstUser without providing the username of the secondUser. Should return an error status and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "SecondUser Unfollow FirstUser Again",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status client error', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \t\"username\": \"{{secondUser}}\",\n  \t\"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}/unfollow",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}",
										"unfollow"
									]
								},
								"description": "Attempts to unfollow the firstUser without providing the username of the secondUser. Should return an error status and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "Get FirstUser Followers Empty",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const userSchema = pm.environment.get('userSchema')",
											"",
											"const schema = {",
											"    'type': 'array',",
											"    'description': 'An array of user dto\\'s',",
											"    'items': { $ref: userSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Array to be empty', () => {",
											"    pm.expect(pm.response.json().length).to.eql(0)",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}/followers",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}",
										"followers"
									]
								},
								"description": "Retrieves the followers of the user with the given username. Only active users should be included in the response. If no active user with the given username exists, an error should be sent in lieu of a response.\n\n#### Response\n```\n[ // Array of Users\n\t{\n\t\t\"username\": \"string\",\n\t\t\"profile\": {\n\t\t\t\"firstName\"?: \"string\",\n\t\t\t\"lastName\"?: \"string\",\n\t\t\t\"email\": \"string\",\n\t\t\t\"phone\"?: \"string\"\n\t\t},\n\t\t\"joined\": timestamp\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "Get SecondUser Following Empty",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const userSchema = pm.environment.get('userSchema')",
											"",
											"const schema = {",
											"    'type': 'array',",
											"    'description': 'An array of user dto\\'s',",
											"    'items': { $ref: userSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Array to be empty', () => {",
											"    pm.expect(pm.response.json().length).to.eql(0)",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}/following",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}",
										"following"
									]
								},
								"description": "Retrieves the followers of the user with the given username. Only active users should be included in the response. If no active user with the given username exists, an error should be sent in lieu of a response.\n\n#### Response\n```\n[ // Array of Users\n\t{\n\t\t\"username\": \"string\",\n\t\t\"profile\": {\n\t\t\t\"firstName\"?: \"string\",\n\t\t\t\"lastName\"?: \"string\",\n\t\t\t\"email\": \"string\",\n\t\t\t\"phone\"?: \"string\"\n\t\t},\n\t\t\"joined\": timestamp\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "SecondUser Follow FirstUser After Unfollow",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Should be success', () => {",
											"    pm.response.to.be.success",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"username\": \"{{secondUser}}\",\n    \"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}/follow",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}",
										"follow"
									]
								},
								"description": "Attempts to follow the secondUser without providing the username of the firstUser. Should return an error status and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "SecondUser Follow FirstUser Again After Unfollow",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status error', () => {",
											"    pm.response.to.not.be.success",
											"})",
											"",
											"pm.test('Should not be internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"username\": \"{{secondUser}}\",\n    \"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}/follow",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}",
										"follow"
									]
								},
								"description": "Attempts to follow the secondUser without providing the username of the firstUser. Should return an error status and no body.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						}
					],
					"description": "Tests for following and unfollowing users"
				},
				{
					"name": "User Feed, Tweets, & Mentions",
					"item": [
						{
							"name": "Get RandomUser Feed",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status error', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@randomUser/feed",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@randomUser",
										"feed"
									]
								},
								"description": "Retrieves all (non-deleted) tweets authored by the user with the given username, as well as all (non-deleted) tweets authored by users the given user is following. This includes simple tweets, reposts, and replies. The tweets should appear in reverse-chronological order. If no active user with that username exists (deleted or never created), an error should be sent in lieu of a response.\n\n#### Response\n```\n[ // Array of Tweets\n\t{\n\t\t\"id\": integer,\n\t\t\"author\": {\n\t\t\t\"username\": \"string\",\n\t\t\t\"profile\": {\n\t\t\t\t\"firstName\"?: \"string\",\n\t\t\t\t\"lastName\"?: \"string\",\n\t\t\t\t\"email\": \"string\",\n\t\t\t\t\"phone\"?: \"string\"\n\t\t\t},\n\t\t\t\"joined\": timestamp\n\t\t},\n\t\t\"posted\": timestamp,\n\t\t\"content\"?: \"string\",\n\t\t\"inReplyTo\"?: {Tweet},\n\t\t\"repostOf\"?: {Tweet}\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "Get RandomUser Tweets",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status error', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@randomUser/tweets",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@randomUser",
										"tweets"
									]
								},
								"description": "Retrieves all (non-deleted) tweets authored by the user with the given username. This includes simple tweets, reposts, and replies. The tweets should appear in reverse-chronological order. If no active user with that username exists (deleted or never created), an error should be sent in lieu of a response.\n\n#### Response\n```\n[ // Array of Tweets\n\t{\n\t\t\"id\": integer,\n\t\t\"author\": {\n\t\t\t\"username\": \"string\",\n\t\t\t\"profile\": {\n\t\t\t\t\"firstName\"?: \"string\",\n\t\t\t\t\"lastName\"?: \"string\",\n\t\t\t\t\"email\": \"string\",\n\t\t\t\t\"phone\"?: \"string\"\n\t\t\t},\n\t\t\t\"joined\": timestamp\n\t\t},\n\t\t\"posted\": timestamp,\n\t\t\"content\"?: \"string\",\n\t\t\"inReplyTo\"?: {Tweet},\n\t\t\"repostOf\"?: {Tweet}\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "Get RandomUser Mentions",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status error', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@randomUser/mentions",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@randomUser",
										"mentions"
									]
								},
								"description": "Retrieves all (non-deleted) tweets in which the user with the given username is mentioned. The tweets should appear in reverse-chronological order. If no active user with that username exists, an error should be sent in lieu of a response.\n\nA user is considered \"mentioned\" by a tweet if the tweet has content and the user's username appears in that content following a ```@```.\n\n#### Response\n```\n[ // Array of Tweets\n\t{\n\t\t\"id\": integer,\n\t\t\"author\": {\n\t\t\t\"username\": \"string\",\n\t\t\t\"profile\": {\n\t\t\t\t\"firstName\"?: \"string\",\n\t\t\t\t\"lastName\"?: \"string\",\n\t\t\t\t\"email\": \"string\",\n\t\t\t\t\"phone\"?: \"string\"\n\t\t\t},\n\t\t\t\"joined\": timestamp\n\t\t},\n\t\t\"posted\": timestamp,\n\t\t\"content\"?: \"string\",\n\t\t\"inReplyTo\"?: {Tweet},\n\t\t\"repostOf\"?: {Tweet}\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "Get SecondUser Feed Empty",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const tweetSchema = pm.environment.get('tweetSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of tweet dto\\'s',",
											"    items: { $ref: tweetSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    pm.test('Should be empty', () => {",
											"        pm.expect(pm.response.json().length).to.eql(0)",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}/feed",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}",
										"feed"
									]
								},
								"description": "Retrieves all (non-deleted) tweets authored by the user with the given username, as well as all (non-deleted) tweets authored by users the given user is following. This includes simple tweets, reposts, and replies. The tweets should appear in reverse-chronological order. If no active user with that username exists (deleted or never created), an error should be sent in lieu of a response.\n\n#### Response\n```\n[ // Array of Tweets\n\t{\n\t\t\"id\": integer,\n\t\t\"author\": {\n\t\t\t\"username\": \"string\",\n\t\t\t\"profile\": {\n\t\t\t\t\"firstName\"?: \"string\",\n\t\t\t\t\"lastName\"?: \"string\",\n\t\t\t\t\"email\": \"string\",\n\t\t\t\t\"phone\"?: \"string\"\n\t\t\t},\n\t\t\t\"joined\": timestamp\n\t\t},\n\t\t\"posted\": timestamp,\n\t\t\"content\"?: \"string\",\n\t\t\"inReplyTo\"?: {Tweet},\n\t\t\"repostOf\"?: {Tweet}\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "Get SecondUser Tweets Empty",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const tweetSchema = pm.environment.get('tweetSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of tweet dto\\'s',",
											"    items: { $ref: tweetSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    pm.test('Should be empty', () => {",
											"        pm.expect(pm.response.json().length).to.eql(0)",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}/tweets",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}",
										"tweets"
									]
								},
								"description": "Retrieves all (non-deleted) tweets authored by the user with the given username. This includes simple tweets, reposts, and replies. The tweets should appear in reverse-chronological order. If no active user with that username exists (deleted or never created), an error should be sent in lieu of a response.\n\n#### Response\n```\n[ // Array of Tweets\n\t{\n\t\t\"id\": integer,\n\t\t\"author\": {\n\t\t\t\"username\": \"string\",\n\t\t\t\"profile\": {\n\t\t\t\t\"firstName\"?: \"string\",\n\t\t\t\t\"lastName\"?: \"string\",\n\t\t\t\t\"email\": \"string\",\n\t\t\t\t\"phone\"?: \"string\"\n\t\t\t},\n\t\t\t\"joined\": timestamp\n\t\t},\n\t\t\"posted\": timestamp,\n\t\t\"content\"?: \"string\",\n\t\t\"inReplyTo\"?: {Tweet},\n\t\t\"repostOf\"?: {Tweet}\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						}
					],
					"description": "Tests for individual user's feeds, tweets, & mentions."
				},
				{
					"name": "Delete User",
					"item": [
						{
							"name": "Delete RandomUser",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n    \"username\": \"{{firstUser}}\",\n    \"password\": \"{{password}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@randomUser",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@randomUser"
									]
								},
								"description": "\"Deletes\" a user with the given username. If no such user exists or the provided credentials do not match the user, an error should be sent in lieu of a response. If a user is successfully \"deleted\", the response should contain the user data prior to deletion.\n\n**IMPORTANT**: This action should not actually drop any records from the database! Instead, develop a way to keep track of \"deleted\" users so that if a user is re-activated, all of their tweets and information are restored.\n\n#### Request\n```\n{\n\t\"credentials\": {\n\t\t\"username\": \"string\",\n\t\t\"password\": \"string\"\n\t}\n}\n```\n\n#### Response\n```\n{ // User\n\t\"username\": \"string\",\n\t\"profile\": {\n\t\t\"firstName\"?: \"string\",\n\t\t\"lastName\"?: \"string\",\n\t\t\"email\": \"string\",\n\t\t\"phone\"?: \"string\"\n\t},\n\t\"joined\": timestamp\n}\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "Delete FirstUser",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('userSchema')",
											"",
											"",
											"pm.test('Success status', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Username is correct', () => {",
											"    pm.expect(pm.response.json().username).to.eql(pm.environment.get('firstUser'))",
											"})",
											"",
											"pm.test('Joined has not been modified', () => {",
											"    pm.expect(new Date(pm.response.json().joined)).to.eql(new Date(pm.environment.get('firstUserJoined')))",
											"})",
											"",
											"pm.test('Profile is correct', () => {",
											"    const profile = pm.response.json().profile",
											"    pm.expect(profile.firstName).to.eql(pm.environment.get('firstUserFirstName'))",
											"    pm.expect(profile.lastName).to.eql(pm.environment.get('firstUserLastName'))",
											"    pm.expect(profile.email).to.eql(pm.environment.get('firstUserEmail'))",
											"    pm.expect(profile.phone).to.eql(pm.environment.get('firstUserPhone'))",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"username\": \"{{firstUser}}\",\n    \"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}"
									]
								},
								"description": "\"Deletes\" a user with the given username. If no such user exists or the provided credentials do not match the user, an error should be sent in lieu of a response. If a user is successfully \"deleted\", the response should contain the user data prior to deletion.\n\n**IMPORTANT**: This action should not actually drop any records from the database! Instead, develop a way to keep track of \"deleted\" users so that if a user is re-activated, all of their tweets and information are restored.\n\n#### Request\n```\n{\n\t\"credentials\": {\n\t\t\"username\": \"string\",\n\t\t\"password\": \"string\"\n\t}\n}\n```\n\n#### Response\n```\n{ // User\n\t\"username\": \"string\",\n\t\"profile\": {\n\t\t\"firstName\"?: \"string\",\n\t\t\"lastName\"?: \"string\",\n\t\t\"email\": \"string\",\n\t\t\"phone\"?: \"string\"\n\t},\n\t\"joined\": timestamp\n}\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "Create FirstUser After Delete",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('userSchema')",
											"",
											"pm.test('Success status', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Username was set correctly', () => {",
											"    pm.expect(pm.response.json().username).to.eql(pm.environment.get('firstUser'))",
											"})",
											"",
											"pm.test('Joined date was set', () => {",
											"    const joined = pm.response.json().joined",
											"    pm.expect(joined).to.not.eql(null)",
											"    pm.expect(joined).to.not.eql(undefined)",
											"    pm.environment.set('firstUserJoined', new Date(joined))",
											"})",
											"",
											"pm.test('Profile was set correctly', () => {",
											"    const profile = pm.response.json().profile",
											"    pm.expect(profile.firstName).to.eql(pm.environment.get('firstUserFirstName'))",
											"    pm.expect(profile.lastName).to.eql(pm.environment.get('firstUserLastName'))",
											"    pm.expect(profile.email).to.eql(pm.environment.get('firstUserEmail'))",
											"    pm.expect(profile.phone).to.eql(pm.environment.get('firstUserPhone'))",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n  \t\"username\": \"{{firstUser}}\",\n    \"password\": \"{{password}}\"\n  },\n  \"profile\": {\n    \"email\": \"{{firstUserEmail}}\",\n    \"firstName\": \"{{firstUserFirstName}}\",\n    \"lastName\": \"{{firstUserLastName}}\",\n    \"phone\": \"{{firstUserPhone}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users"
									]
								},
								"description": "If a user tries to create a user without a username, an error code of some kind should be sent in leu of a response.\n\nExpected Status: An \"error\" status code. Somewhere in the 400s or 500s.\nNo Response Body expected. If the student adds more advanced error handling though, we should not penalize them."
							},
							"response": []
						},
						{
							"name": "Create FirstUser After Delete Again",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Error status', () => {",
											"    pm.response.to.not.be.info",
											"    pm.response.to.not.be.success",
											"})",
											"",
											"pm.test('Should not be internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n  \t\"username\": \"{{firstUser}}\",\n    \"password\": \"{{password}}\"\n  },\n  \"profile\": {\n    \"email\": \"{{firstUserEmail}}\",\n    \"firstName\": \"{{firstUserFirstName}}\",\n    \"lastName\": \"{{firstUserLastName}}\",\n    \"phone\": \"{{firstUserPhone}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/users",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users"
									]
								},
								"description": "If a user tries to create a user without a username, an error code of some kind should be sent in leu of a response.\n\nExpected Status: An \"error\" status code. Somewhere in the 400s or 500s.\nNo Response Body expected. If the student adds more advanced error handling though, we should not penalize them."
							},
							"response": []
						}
					],
					"description": "Tests for deleting users."
				}
			]
		},
		{
			"name": "Tweet",
			"item": [
				{
					"name": "Create New Tweets",
					"item": [
						{
							"name": "Get All Tags Empty",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const hashtagSchema = pm.environment.get('hashtagSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of user dto\\'s',",
											"    items: { $ref: hashtagSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Returns an empty array', () => {",
											"    pm.expect(pm.response.json().length).to.eql(0)",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tags",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tags"
									]
								},
								"description": "Retrieves all hashtags tracked by the database.\n\nResponse:\n[\n  {\n    \"firstUsed\": {firstUsedDate},\n    \"label\": \"{label}\",\n    \"lastUsed\": {lastUsedDate}\n  }\n]"
							},
							"response": []
						},
						{
							"name": "FirstUser Post Tweet Fail (No Content)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success', () => {",
											"    pm.response.to.not.be.success",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"credentials\": {\n    \"username\": \"{{firstUser}}\",\n    \"password\": \"{{password}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/tweets",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets"
									]
								},
								"description": "Attempts to create a tweet with no content. Should return an error status with no content.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "FirstUser Post Tweet Fail (No Credentials)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success', () => {",
											"    pm.response.to.not.be.success",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"content\": \"{{firstUserTweet}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/tweets",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets"
									]
								},
								"description": "Attempts to create a tweet with no credentials. Should return an error status with no content.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "FirstUser Post Tweet Fail (No Password)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success', () => {",
											"    pm.response.to.not.be.success",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"content\": \"{{firstUserTweet}}\",\n  \"credentials\": {\n    \"username\": \"{{firstUser}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/tweets",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets"
									]
								},
								"description": "Attempts to create a tweet with no password in the credentials. Should return an error status with no content.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "FirstUser Post Tweet Fail (No Username)",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success', () => {",
											"    pm.response.to.not.be.success",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"content\": \"{{firstUserTweet}}\",\n  \"credentials\": {\n    \"password\": \"{{password}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/tweets",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets"
									]
								},
								"description": "Attempts to create a tweet with no username in the credentials. Should return an error status with no content.\n\nExpected Status: error\nExpected Body: none"
							},
							"response": []
						},
						{
							"name": "FirstUser Post Tweet",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('tweetSchema')",
											"",
											"pm.test('Schema is valid', () => {",
											"    pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Tweet has id', () => {",
											"    pm.expect(pm.response.json().id).to.not.eql(null)",
											"    pm.environment.set('firstTweetId', pm.response.json().id)",
											"})",
											"",
											"pm.test('Author is correct', () => {",
											"    const author = pm.response.json().author",
											"    pm.expect(author.username).to.eql(pm.environment.get('firstUser'))",
											"    pm.expect(new Date(author.joined)).to.eql(new Date(pm.environment.get('firstUserJoined')))",
											"    const profile = author.profile",
											"    pm.expect(profile.firstName).to.eql(pm.environment.get('firstUserFirstName'))",
											"    pm.expect(profile.lastName).to.eql(pm.environment.get('firstUserLastName'))",
											"    pm.expect(profile.email).to.eql(pm.environment.get('firstUserEmail'))",
											"    pm.expect(profile.phone).to.eql(pm.environment.get('firstUserPhone'))",
											"})",
											"",
											"pm.test('Tweet has date posted', () => {",
											"    pm.expect(pm.response.json().posted).to.not.eql(null)",
											"})",
											"",
											"pm.test('Tweet content is correct', () => {",
											"    pm.expect(pm.response.json().content).to.eql(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"content\": \"{{firstUserTweet}}\",\n  \"credentials\": {\n    \"username\": \"{{firstUser}}\",\n    \"password\": \"{{password}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/tweets",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets"
									]
								},
								"description": "Creates a new simple tweet, with the author set to the user indentified by the credentials in the request body. If the given credentials do not match an active user in the database, an error should be sent in lieu of a resopnse.\n\nThe response should contain the newly-created tweet.\n\nBecause this always creates a simple tweet, it must have a content property and may not have inReplyTo or repostOf properties.\n\nIMPORTANT: when a tweet with content is created, the server must process the tweet's content for @{username} mentions and #{hashtag} tags. There is no way to create hashtags or create mentions from the API, so this must be handled automatically!\n\nRequest:\n{\n  \"content\": \"{content}\",\n  \"credentials\": {\n    \"username\": \"{username}\"\n    \"password\": \"{password}\"\n  }\n}\n\nResponse:\n{\n  \"id\": {id},\n  \"content\": \"{content}\",\n  \"posted\": {postedDate}\n  \"author\": {\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n      \"email\": \"{email}\",\n      \"firstName\": \"{firstname}\",\n      \"lastName\": \"{lastname}\",\n      \"phone\": \"{phoneNumber}\"\n    }\n  }\n}"
							},
							"response": []
						},
						{
							"name": "Get FirstUser Feed",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const tweetSchema = pm.environment.get('tweetSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of tweet dto\\'s',",
											"    items: { $ref: tweetSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const content = pm.response.json().map(tweet => tweet.content)",
											"    const authors = pm.response.json().map(tweet => tweet.author.username)",
											"    ",
											"    pm.test('Should only contain the first user\\'s tweet', () => {",
											"        pm.expect(pm.response.json().length).to.eql(1)",
											"    })",
											"    ",
											"    pm.test('Contains the firstUser\\'s tweet', () => {",
											"        pm.expect(content).to.include(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)",
											"        pm.expect(authors).to.include(pm.environment.get('firstUser'))",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}/feed",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}",
										"feed"
									]
								},
								"description": "Retrieves all (non-deleted) tweets authored by the user with the given username, as well as all (non-deleted) tweets authored by users the given user is following. This includes simple tweets, reposts, and replies. The tweets should appear in reverse-chronological order. If no active user with that username exists (deleted or never created), an error should be sent in lieu of a response.\n\n#### Response\n```\n[ // Array of Tweets\n\t{\n\t\t\"id\": integer,\n\t\t\"author\": {\n\t\t\t\"username\": \"string\",\n\t\t\t\"profile\": {\n\t\t\t\t\"firstName\"?: \"string\",\n\t\t\t\t\"lastName\"?: \"string\",\n\t\t\t\t\"email\": \"string\",\n\t\t\t\t\"phone\"?: \"string\"\n\t\t\t},\n\t\t\t\"joined\": timestamp\n\t\t},\n\t\t\"posted\": timestamp,\n\t\t\"content\"?: \"string\",\n\t\t\"inReplyTo\"?: {Tweet},\n\t\t\"repostOf\"?: {Tweet}\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "Get FirstUser Tweets",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const tweetSchema = pm.environment.get('tweetSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of tweet dto\\'s',",
											"    items: { $ref: tweetSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const content = pm.response.json().map(tweet => tweet.content)",
											"    const authors = pm.response.json().map(tweet => tweet.author.username)",
											"    ",
											"    pm.test('Should only contain the first user\\'s tweet', () => {",
											"        pm.expect(pm.response.json().length).to.eql(1)",
											"    })",
											"    ",
											"    pm.test('Contains the firstUser\\'s tweet', () => {",
											"        pm.expect(content).to.include(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)",
											"        pm.expect(authors).to.include(pm.environment.get('firstUser'))",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}/tweets",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}",
										"tweets"
									]
								},
								"description": "Retrieves all (non-deleted) tweets authored by the user with the given username. This includes simple tweets, reposts, and replies. The tweets should appear in reverse-chronological order. If no active user with that username exists (deleted or never created), an error should be sent in lieu of a response.\n\n#### Response\n```\n[ // Array of Tweets\n\t{\n\t\t\"id\": integer,\n\t\t\"author\": {\n\t\t\t\"username\": \"string\",\n\t\t\t\"profile\": {\n\t\t\t\t\"firstName\"?: \"string\",\n\t\t\t\t\"lastName\"?: \"string\",\n\t\t\t\t\"email\": \"string\",\n\t\t\t\t\"phone\"?: \"string\"\n\t\t\t},\n\t\t\t\"joined\": timestamp\n\t\t},\n\t\t\"posted\": timestamp,\n\t\t\"content\"?: \"string\",\n\t\t\"inReplyTo\"?: {Tweet},\n\t\t\"repostOf\"?: {Tweet}\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "Get FirstUser Mentions Empty",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const tweetSchema = pm.environment.get('tweetSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of tweet dto\\'s',",
											"    items: { $ref: tweetSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    pm.test('Should be empty', () => {",
											"        pm.expect(pm.response.json().length).to.eql(0)",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}/mentions",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}",
										"mentions"
									]
								},
								"description": "Retrieves all (non-deleted) tweets in which the user with the given username is mentioned. The tweets should appear in reverse-chronological order. If no active user with that username exists, an error should be sent in lieu of a response.\n\nA user is considered \"mentioned\" by a tweet if the tweet has content and the user's username appears in that content following a ```@```.\n\n#### Response\n```\n[ // Array of Tweets\n\t{\n\t\t\"id\": integer,\n\t\t\"author\": {\n\t\t\t\"username\": \"string\",\n\t\t\t\"profile\": {\n\t\t\t\t\"firstName\"?: \"string\",\n\t\t\t\t\"lastName\"?: \"string\",\n\t\t\t\t\"email\": \"string\",\n\t\t\t\t\"phone\"?: \"string\"\n\t\t\t},\n\t\t\t\"joined\": timestamp\n\t\t},\n\t\t\"posted\": timestamp,\n\t\t\"content\"?: \"string\",\n\t\t\"inReplyTo\"?: {Tweet},\n\t\t\"repostOf\"?: {Tweet}\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "Get SecondUser Mentions",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const tweetSchema = pm.environment.get('tweetSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of tweet dto\\'s',",
											"    items: { $ref: tweetSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const content = pm.response.json().map(tweet => tweet.content)",
											"    const authors = pm.response.json().map(tweet => tweet.author.username)",
											"    ",
											"    pm.test('Should only contain the first user\\'s tweet', () => {",
											"        pm.expect(pm.response.json().length).to.eql(1)",
											"    })",
											"    ",
											"    pm.test('Contains the firstUser\\'s tweet', () => {",
											"        pm.expect(content).to.include(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)",
											"        pm.expect(authors).to.include(pm.environment.get('firstUser'))",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}/mentions",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}",
										"mentions"
									]
								},
								"description": "Retrieves all (non-deleted) tweets in which the user with the given username is mentioned. The tweets should appear in reverse-chronological order. If no active user with that username exists, an error should be sent in lieu of a response.\n\nA user is considered \"mentioned\" by a tweet if the tweet has content and the user's username appears in that content following a ```@```.\n\n#### Response\n```\n[ // Array of Tweets\n\t{\n\t\t\"id\": integer,\n\t\t\"author\": {\n\t\t\t\"username\": \"string\",\n\t\t\t\"profile\": {\n\t\t\t\t\"firstName\"?: \"string\",\n\t\t\t\t\"lastName\"?: \"string\",\n\t\t\t\t\"email\": \"string\",\n\t\t\t\t\"phone\"?: \"string\"\n\t\t\t},\n\t\t\t\"joined\": timestamp\n\t\t},\n\t\t\"posted\": timestamp,\n\t\t\"content\"?: \"string\",\n\t\t\"inReplyTo\"?: {Tweet},\n\t\t\"repostOf\"?: {Tweet}\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "SecondUser Post Tweet",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('tweetSchema')",
											"",
											"pm.test(\"Schema is valid\", () => {",
											"    pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test(\"Tweet has id\", () => {",
											"    pm.expect(pm.response.json().id).to.not.eql(null)",
											"    pm.environment.set(\"secondTweetId\", pm.response.json().id)",
											"})",
											"",
											"pm.test(\"Author is correct\", () => {",
											"    const author = pm.response.json().author",
											"    pm.expect(author.username).to.eql(pm.environment.get(\"secondUser\"))",
											"    pm.expect(new Date(author.joined)).to.eql(new Date(pm.environment.get(\"secondUserJoined\")))",
											"    const profile = author.profile",
											"    pm.expect(profile.firstName).to.eql(pm.environment.get(\"secondUserFirstName\"))",
											"    pm.expect(profile.lastName).to.eql(pm.environment.get(\"secondUserLastName\"))",
											"    pm.expect(profile.email).to.eql(pm.environment.get(\"secondUserEmail\"))",
											"    pm.expect(profile.phone).to.eql(pm.environment.get(\"secondUserPhone\"))",
											"})",
											"",
											"pm.test(\"Tweet has date posted\", () => {",
											"    pm.expect(pm.response.json().posted).to.not.eql(null)",
											"})",
											"",
											"pm.test(\"Tweet content is correct\", () => {",
											"    pm.expect(pm.response.json().content).to.eql(`Tweet from the second user! @${pm.environment.get(\"firstUser\")} #${pm.environment.get(\"secondTag\")}`)",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"content\": \"{{secondUserTweet}}\",\n  \"credentials\": {\n    \"username\": \"{{secondUser}}\",\n    \"password\": \"{{password}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/tweets",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets"
									]
								},
								"description": "Creates a new simple tweet, with the author set to the user indentified by the credentials in the request body. If the given credentials do not match an active user in the database, an error should be sent in lieu of a resopnse.\n\nThe response should contain the newly-created tweet.\n\nBecause this always creates a simple tweet, it must have a content property and may not have inReplyTo or repostOf properties.\n\nIMPORTANT: when a tweet with content is created, the server must process the tweet's content for @{username} mentions and #{hashtag} tags. There is no way to create hashtags or create mentions from the API, so this must be handled automatically!\n\nRequest:\n{\n  \"content\": \"{content}\",\n  \"credentials\": {\n    \"username\": \"{username}\"\n    \"password\": \"{password}\"\n  }\n}\n\nResponse:\n{\n  \"id\": {id},\n  \"content\": \"{content}\",\n  \"posted\": {postedDate}\n  \"author\": {\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n      \"email\": \"{email}\",\n      \"firstName\": \"{firstname}\",\n      \"lastName\": \"{lastname}\",\n      \"phone\": \"{phoneNumber}\"\n    }\n  }\n}"
							},
							"response": []
						},
						{
							"name": "Get SecondUser Feed",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const tweetSchema = pm.environment.get('tweetSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of tweet dto\\'s',",
											"    items: { $ref: tweetSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const content = pm.response.json().map(tweet => tweet.content)",
											"    const authors = pm.response.json().map(tweet => tweet.author.username)",
											"    ",
											"    pm.test('Should contain both the first and second tweets', () => {",
											"        pm.expect(pm.response.json().length).to.eql(2)",
											"    })",
											"    ",
											"    pm.test('Contains the firstUser\\'s tweet', () => {",
											"        pm.expect(content).to.include(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)",
											"        pm.expect(authors).to.include(pm.environment.get('firstUser'))",
											"    })",
											"    ",
											"    pm.test('Contains the secondUser\\'s tweet', () => {",
											"        pm.expect(content).to.include(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)",
											"        pm.expect(authors).to.include(pm.environment.get('secondUser'))",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}/feed",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}",
										"feed"
									]
								},
								"description": "Retrieves all (non-deleted) tweets authored by the user with the given username, as well as all (non-deleted) tweets authored by users the given user is following. This includes simple tweets, reposts, and replies. The tweets should appear in reverse-chronological order. If no active user with that username exists (deleted or never created), an error should be sent in lieu of a response.\n\n#### Response\n```\n[ // Array of Tweets\n\t{\n\t\t\"id\": integer,\n\t\t\"author\": {\n\t\t\t\"username\": \"string\",\n\t\t\t\"profile\": {\n\t\t\t\t\"firstName\"?: \"string\",\n\t\t\t\t\"lastName\"?: \"string\",\n\t\t\t\t\"email\": \"string\",\n\t\t\t\t\"phone\"?: \"string\"\n\t\t\t},\n\t\t\t\"joined\": timestamp\n\t\t},\n\t\t\"posted\": timestamp,\n\t\t\"content\"?: \"string\",\n\t\t\"inReplyTo\"?: {Tweet},\n\t\t\"repostOf\"?: {Tweet}\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "Get SecondUser Tweets",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const tweetSchema = pm.environment.get('tweetSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of tweet dto\\'s',",
											"    items: { $ref: tweetSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const content = pm.response.json().map(tweet => tweet.content)",
											"    const authors = pm.response.json().map(tweet => tweet.author.username)",
											"    ",
											"    pm.test('Should only contain the second user\\'s tweet', () => {",
											"        pm.expect(pm.response.json().length).to.eql(1)",
											"    })",
											"    ",
											"    pm.test('Contains the secondUser\\'s tweet', () => {",
											"        pm.expect(content).to.include(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)",
											"        pm.expect(authors).to.include(pm.environment.get('secondUser'))",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{secondUser}}/tweets",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{secondUser}}",
										"tweets"
									]
								},
								"description": "Retrieves all (non-deleted) tweets authored by the user with the given username. This includes simple tweets, reposts, and replies. The tweets should appear in reverse-chronological order. If no active user with that username exists (deleted or never created), an error should be sent in lieu of a response.\n\n#### Response\n```\n[ // Array of Tweets\n\t{\n\t\t\"id\": integer,\n\t\t\"author\": {\n\t\t\t\"username\": \"string\",\n\t\t\t\"profile\": {\n\t\t\t\t\"firstName\"?: \"string\",\n\t\t\t\t\"lastName\"?: \"string\",\n\t\t\t\t\"email\": \"string\",\n\t\t\t\t\"phone\"?: \"string\"\n\t\t\t},\n\t\t\t\"joined\": timestamp\n\t\t},\n\t\t\"posted\": timestamp,\n\t\t\"content\"?: \"string\",\n\t\t\"inReplyTo\"?: {Tweet},\n\t\t\"repostOf\"?: {Tweet}\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						},
						{
							"name": "Get FirstUser Mentions",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const tweetSchema = pm.environment.get('tweetSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of tweet dto\\'s',",
											"    items: { $ref: tweetSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const content = pm.response.json().map(tweet => tweet.content)",
											"    const authors = pm.response.json().map(tweet => tweet.author.username)",
											"    ",
											"    pm.test('Should only contain the second user\\'s tweet', () => {",
											"        pm.expect(pm.response.json().length).to.eql(1)",
											"    })",
											"    ",
											"    pm.test('Contains the secondUser\\'s tweet', () => {",
											"        pm.expect(content).to.include(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)",
											"        pm.expect(authors).to.include(pm.environment.get('secondUser'))",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/users/@{{firstUser}}/mentions",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"users",
										"@{{firstUser}}",
										"mentions"
									]
								},
								"description": "Retrieves all (non-deleted) tweets in which the user with the given username is mentioned. The tweets should appear in reverse-chronological order. If no active user with that username exists, an error should be sent in lieu of a response.\n\nA user is considered \"mentioned\" by a tweet if the tweet has content and the user's username appears in that content following a ```@```.\n\n#### Response\n```\n[ // Array of Tweets\n\t{\n\t\t\"id\": integer,\n\t\t\"author\": {\n\t\t\t\"username\": \"string\",\n\t\t\t\"profile\": {\n\t\t\t\t\"firstName\"?: \"string\",\n\t\t\t\t\"lastName\"?: \"string\",\n\t\t\t\t\"email\": \"string\",\n\t\t\t\t\"phone\"?: \"string\"\n\t\t\t},\n\t\t\t\"joined\": timestamp\n\t\t},\n\t\t\"posted\": timestamp,\n\t\t\"content\"?: \"string\",\n\t\t\"inReplyTo\"?: {Tweet},\n\t\t\"repostOf\"?: {Tweet}\n\t}\n]\n```\n\n* Remember that question marks denote optional values."
							},
							"response": []
						}
					],
					"description": "Tests for creating new tweets and validating tags are created as well."
				},
				{
					"name": "Tweet Tags and Mentions",
					"item": [
						{
							"name": "Get RandomTweet Tags",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status error', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tweets/randomTweet/tags",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"randomTweet",
										"tags"
									]
								},
								"description": "Retrieves the tags associated with the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a resonse.\n\nIMPORTANT: Remember that tags and mentions must be parsed by the server!\n\nResponse:\n[\n  {\n    \"firstUsed\": {firstUsedDate},\n    \"label\": \"{label}\",\n    \"lastUsed\": {lastUsedDate}\n  }\n]"
							},
							"response": []
						},
						{
							"name": "Get FirstTweet Tags",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const hashtagSchema = pm.environment.get('hashtagSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of hashtag dto\\'s',",
											"    items: { $ref: hashtagSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Should contain two values', () => {",
											"    pm.expect(pm.response.json().length).to.eql(1)",
											"})",
											"",
											"pm.test('Should contain the first hashtag', () => {",
											"    const hashtags = pm.response.json().map(hashtag => hashtag.label)",
											"    pm.expect(hashtags).to.include(pm.environment.get('firstTag'))",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tweets/{{firstTweetId}}/tags",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{firstTweetId}}",
										"tags"
									]
								},
								"description": "Retrieves the tags associated with the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a resonse.\n\nIMPORTANT: Remember that tags and mentions must be parsed by the server!\n\nResponse:\n[\n  {\n    \"firstUsed\": {firstUsedDate},\n    \"label\": \"{label}\",\n    \"lastUsed\": {lastUsedDate}\n  }\n]"
							},
							"response": []
						},
						{
							"name": "Get SecondTweet Tags",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const hashtagSchema = pm.environment.get('hashtagSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of hashtag dto\\'s',",
											"    items: { $ref: hashtagSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Should contain two values', () => {",
											"    pm.expect(pm.response.json().length).to.eql(1)",
											"})",
											"",
											"pm.test('Should contain the second hashtag', () => {",
											"    const hashtags = pm.response.json().map(hashtag => hashtag.label)",
											"    pm.expect(hashtags).to.include(pm.environment.get('secondTag'))",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tweets/{{secondTweetId}}/tags",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{secondTweetId}}",
										"tags"
									]
								},
								"description": "Retrieves the tags associated with the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a resonse.\n\nIMPORTANT: Remember that tags and mentions must be parsed by the server!\n\nResponse:\n[\n  {\n    \"firstUsed\": {firstUsedDate},\n    \"label\": \"{label}\",\n    \"lastUsed\": {lastUsedDate}\n  }\n]"
							},
							"response": []
						},
						{
							"name": "Get FirstTweet Mentions",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const userSchema = pm.environment.get('userSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of user dto\\'s',",
											"    items: { $ref: userSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Returns an with only the second user', () => {",
											"    pm.expect(pm.response.json().length).to.eql(1)",
											"})",
											"",
											"if (pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const users = pm.response.json().map(user => user.username)",
											"    ",
											"    pm.test('Contains the secondUser', () => {",
											"        pm.expect(users).to.include(pm.environment.get('secondUser'))",
											"    })",
											"}",
											"",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tweets/{{firstTweetId}}/mentions",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{firstTweetId}}",
										"mentions"
									]
								},
								"description": "Retrieves the users mentioned in the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a response.\n\nDeleted users should be excluded from the response.\n\nIMPORTANT: Remember that tags and mentions must be parsed by the server!\n\nResponse:\n[\n  {\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n        \"firstName\": \"{firstName}\",\n        \"lastName\": \"{lastName}\",\n        \"email\": \"{email}\",\n        \"phone\": \"{phoneNumber}\"\n    }\n  }\n]"
							},
							"response": []
						},
						{
							"name": "Get SecondTweet Mentions",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const userSchema = pm.environment.get('userSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of user dto\\'s',",
											"    items: { $ref: userSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Returns an with only the first user', () => {",
											"    pm.expect(pm.response.json().length).to.eql(1)",
											"})",
											"",
											"if (pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const users = pm.response.json().map(user => user.username)",
											"    ",
											"    pm.test('Contains the firstUser', () => {",
											"        pm.expect(users).to.include(pm.environment.get('firstUser'))",
											"    })",
											"}",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tweets/{{secondTweetId}}/mentions",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{secondTweetId}}",
										"mentions"
									]
								},
								"description": "Retrieves the users mentioned in the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a response.\n\nDeleted users should be excluded from the response.\n\nIMPORTANT: Remember that tags and mentions must be parsed by the server!\n\nResponse:\n[\n  {\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n        \"firstName\": \"{firstName}\",\n        \"lastName\": \"{lastName}\",\n        \"email\": \"{email}\",\n        \"phone\": \"{phoneNumber}\"\n    }\n  }\n]"
							},
							"response": []
						}
					],
					"description": "Tests for retrieving tags and mentions from tweets."
				},
				{
					"name": "Get Tweets",
					"item": [
						{
							"name": "Get All Tweets",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const tweetSchema = pm.environment.get('tweetSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of tweet dto\\'s',",
											"    items: { $ref: tweetSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const content = pm.response.json().map(tweet => tweet.content)",
											"    const authors = pm.response.json().map(tweet => tweet.author.username)",
											"    ",
											"    pm.test('Should contain both the first and second tweets', () => {",
											"        pm.expect(pm.response.json().length).to.eql(2)",
											"    })",
											"    ",
											"    pm.test('Contains the firstUser\\'s tweet', () => {",
											"        pm.expect(content).to.include(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)",
											"        pm.expect(authors).to.include(pm.environment.get('firstUser'))",
											"    })",
											"    ",
											"    pm.test('Contains the secondUser\\'s tweet', () => {",
											"        pm.expect(content).to.include(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)",
											"        pm.expect(authors).to.include(pm.environment.get('secondUser'))",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tweets",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets"
									]
								},
								"description": "Retrieves all (non-deleted) tweets. The tweets should appear in reverse-chronological order.\n\nResponse:\n[\n  {\n    \"id\": {id},\n    \"content\": \"{content}\",\n    \"posted\": {postedDate}\n    \"author\": {\n      \"username\": \"{username}\",\n      \"joined\": {joinedDate},\n      \"profile\": {\n        \"email\": \"{email}\",\n        \"firstName\": \"{firstname}\",\n        \"lastName\": \"{lastname}\",\n        \"phone\": \"{phoneNumber}\"\n      }\n    }\n  }\n]"
							},
							"response": []
						},
						{
							"name": "Get FirstTweet",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('tweetSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Author should be the firstUser', () => {",
											"    pm.expect(pm.response.json().author.username).to.eql(pm.environment.get('firstUser'))",
											"})",
											"",
											"pm.test('Content should be the firstTweet', () => {",
											"     pm.expect(pm.response.json().content).to.eql(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tweets/{{firstTweetId}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{firstTweetId}}"
									]
								},
								"description": "Retrieves a tweet with a given id. If no such tweet exists, or the given tweet is deleted, an error should be sent in lieu of a response.\n\nResponse:\n{\n  \"id\": {id},\n  \"content\": \"{content}\",\n  \"posted\": {postedDate}\n  \"author\": {\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n      \"email\": \"{email}\",\n      \"firstName\": \"{firstname}\",\n      \"lastName\": \"{lastname}\",\n      \"phone\": \"{phoneNumber}\"\n    }\n  }\n}"
							},
							"response": []
						},
						{
							"name": "Get SecondTweet",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('tweetSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Author should be the secondUser', () => {",
											"    pm.expect(pm.response.json().author.username).to.eql(pm.environment.get('secondUser'))",
											"})",
											"",
											"pm.test('Content should be the secondTweet', () => {",
											"     pm.expect(pm.response.json().content).to.eql(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tweets/{{secondTweetId}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{secondTweetId}}"
									]
								},
								"description": "Retrieves a tweet with a given id. If no such tweet exists, or the given tweet is deleted, an error should be sent in lieu of a response.\n\nResponse:\n{\n  \"id\": {id},\n  \"content\": \"{content}\",\n  \"posted\": {postedDate}\n  \"author\": {\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n      \"email\": \"{email}\",\n      \"firstName\": \"{firstname}\",\n      \"lastName\": \"{lastname}\",\n      \"phone\": \"{phoneNumber}\"\n    }\n  }\n}"
							},
							"response": []
						},
						{
							"name": "Get FirstTag",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const tweetSchema = pm.environment.get('tweetSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of tweet dto\\'s',",
											"    items: { $ref: tweetSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const content = pm.response.json().map(tweet => tweet.content)",
											"    const authors = pm.response.json().map(tweet => tweet.author.username)",
											"    ",
											"    pm.test('Should only contain the first user\\'s tweet', () => {",
											"        pm.expect(pm.response.json().length).to.eql(1)",
											"    })",
											"    ",
											"    pm.test('Contains the firstUser\\'s tweet', () => {",
											"        pm.expect(content).to.include(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)",
											"        pm.expect(authors).to.include(pm.environment.get('firstUser'))",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tags/{{firstTag}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tags",
										"{{firstTag}}"
									]
								},
								"description": "Retrieves all (non-deleted) tweets tagged with the given hashtag label. The tweets should appear in reverse-chronological order. If no hashtag with the given label exists, an error should be sent in lieu of a response.\n\nA tweet is considered \"tagged\" by a hashtag if the tweet has content and the hashtag's label appears in that content following a #.\n\nResponse:\n[\n  {\n    \"id\": {id},\n    \"content\": \"{content}\",\n    \"posted\": {postedDate}\n    \"author\": {\n      \"username\": \"{username}\",\n      \"joined\": {joinedDate},\n      \"profile\": {\n        \"email\": \"{email}\",\n        \"firstName\": \"{firstname}\",\n        \"lastName\": \"{lastname}\",\n        \"phone\": \"{phoneNumber}\"\n      }\n    }\n  }\n]"
							},
							"response": []
						},
						{
							"name": "Get SecondTag",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const tweetSchema = pm.environment.get('tweetSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of tweet dto\\'s',",
											"    items: { $ref: tweetSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const content = pm.response.json().map(tweet => tweet.content)",
											"    const authors = pm.response.json().map(tweet => tweet.author.username)",
											"    ",
											"    pm.test('Should only contain the second user\\'s tweet', () => {",
											"        pm.expect(pm.response.json().length).to.eql(1)",
											"    })",
											"    ",
											"    pm.test('Contains the secondUser\\'s tweet', () => {",
											"        pm.expect(content).to.include(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)",
											"        pm.expect(authors).to.include(pm.environment.get('secondUser'))",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tags/{{secondTag}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tags",
										"{{secondTag}}"
									]
								},
								"description": "Retrieves all (non-deleted) tweets tagged with the given hashtag label. The tweets should appear in reverse-chronological order. If no hashtag with the given label exists, an error should be sent in lieu of a response.\n\nA tweet is considered \"tagged\" by a hashtag if the tweet has content and the hashtag's label appears in that content following a #.\n\nResponse:\n[\n  {\n    \"id\": {id},\n    \"content\": \"{content}\",\n    \"posted\": {postedDate}\n    \"author\": {\n      \"username\": \"{username}\",\n      \"joined\": {joinedDate},\n      \"profile\": {\n        \"email\": \"{email}\",\n        \"firstName\": \"{firstname}\",\n        \"lastName\": \"{lastname}\",\n        \"phone\": \"{phoneNumber}\"\n      }\n    }\n  }\n]"
							},
							"response": []
						}
					],
					"description": "Tests for retrieving tweets."
				},
				{
					"name": "Liking Tweets",
					"item": [
						{
							"name": "FirstUser Like SecondUserTweet",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Should be success', () => {",
											"    pm.response.to.be.success",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"username\": \"{{firstUser}}\",\n  \"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/tweets/{{secondTweetId}}/like",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{secondTweetId}}",
										"like"
									]
								},
								"description": "Creates a \"like\" relationship between the tweet with the given id and the user whose credentials are provided in the request body. If the tweet is deleted or otherwise doesn't exist, or if the given credentials do not match an active user in the database, an error should be sent. Following successful completion of the operation, no response body is sent.\n\nRequest:\n{\n\t\"username\": {{username}},\n\t\"password\": {{password}}\n}"
							},
							"response": []
						},
						{
							"name": "FirstUser Like SecondUserTweet Again",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Should be success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Should not be internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"username\": \"{{firstUser}}\",\n  \"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/tweets/{{secondTweetId}}/like",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{secondTweetId}}",
										"like"
									]
								},
								"description": "Creates a \"like\" relationship between the tweet with the given id and the user whose credentials are provided in the request body. If the tweet is deleted or otherwise doesn't exist, or if the given credentials do not match an active user in the database, an error should be sent. Following successful completion of the operation, no response body is sent.\n\nRequest:\n{\n  \"username\": {{username}},\n  \"password\": {{password}}\n}"
							},
							"response": []
						},
						{
							"name": "Get SecondTweet Likes",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const userSchema = pm.environment.get('userSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of user dto\\'s',",
											"    items: { $ref: userSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Returns an array with one user', () => {",
											"    pm.expect(pm.response.json().length).to.eql(1)",
											"})",
											"",
											"if (pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const users = pm.response.json().map(user => user.username)",
											"    ",
											"    pm.test('Contains the firstUser', () => {",
											"        pm.expect(users).to.include(pm.environment.get('firstUser'))",
											"    })",
											"}",
											"",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tweets/{{secondTweetId}}/likes",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{secondTweetId}}",
										"likes"
									]
								},
								"description": "Retrieves the active users who have liked the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a response.\n\nDeleted users should be excluded from the response.\n\nResponse:\n[\n  {\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n      \"firstName\": \"{firstName}\",\n      \"lastName\": \"{lastName}\",\n      \"email\": \"{email}\",\n      \"phone\": \"{phoneNumber}\"\n    }\n  }\n]"
							},
							"response": []
						}
					],
					"description": "Tests for liking tweets and retrieving users who like tweets."
				},
				{
					"name": "Tweet Replies",
					"item": [
						{
							"name": "FirstUser Reply To SecondUserTweet",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('tweetSchema')",
											"",
											"pm.test('Schema is valid', () => {",
											"    pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Tweet has id', () => {",
											"    pm.expect(pm.response.json().id).to.not.eql(null)",
											"    pm.environment.set('firstUserReplyId', pm.response.json().id)",
											"})",
											"",
											"pm.test('Author is correct', () => {",
											"    const author = pm.response.json().author",
											"    pm.expect(author.username).to.eql(pm.environment.get('firstUser'))",
											"    pm.expect(new Date(author.joined)).to.eql(new Date(pm.environment.get('firstUserJoined')))",
											"    const profile = author.profile",
											"    pm.expect(profile.firstName).to.eql(pm.environment.get('firstUserFirstName'))",
											"    pm.expect(profile.lastName).to.eql(pm.environment.get('firstUserLastName'))",
											"    pm.expect(profile.email).to.eql(pm.environment.get('firstUserEmail'))",
											"    pm.expect(profile.phone).to.eql(pm.environment.get('firstUserPhone'))",
											"})",
											"",
											"pm.test('Tweet has date posted', () => {",
											"    pm.expect(pm.response.json().posted).to.not.eql(null)",
											"})",
											"",
											"pm.test('Tweet content is correct', () => {",
											"    pm.expect(pm.response.json().content).to.eql(pm.environment.get('firstUserReply'))",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"content\": \"{{firstUserReply}}\",\n  \"credentials\": {\n    \"username\": \"{{firstUser}}\",\n    \"password\": \"{{password}}\"\n  }\n}"
								},
								"url": {
									"raw": "localhost:8080/tweets/{{secondTweetId}}/reply",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{secondTweetId}}",
										"reply"
									]
								},
								"description": "Creates a reply tweet to the tweet with the given id. The author of the newly-created tweet should match the credentials provided by the request body. If the given tweet is deleted or otherwise doesn't exist, or if the given credentials do not match an active user in the database, an error should be sent in lieu of a response.\n\nBecause this creates a reply tweet, content is not optional. Additionally, notice that the inReplyTo property is not provided by the request. The server must create that relationship.\n\nThe response should contain the newly-created tweet.\n\nIMPORTANT: when a tweet with content is created, the server must process the tweet's content for @{username} mentions and #{hashtag} tags. There is no way to create hashtags or create mentions from the API, so this must be handled automatically!\n\nRequest:\n{\n\t\"content\": \"{content}\",\n\t\"credentials\": {\n\t\t\"username\": \"{username}\",\n\t\t\"password\": \"{password}\"\n\t}\n}\n\nResponse:\n{\n  \"id\": {id},\n  \"content\": \"{content}\",\n  \"posted\": {postedDate}\n  \"author\": {\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n      \"email\": \"{email}\",\n      \"firstName\": \"{firstname}\",\n      \"lastName\": \"{lastname}\",\n      \"phone\": \"{phoneNumber}\"\n    }\n  }\n}"
							},
							"response": []
						},
						{
							"name": "Get SecondTweet Replies",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const tweetSchema = pm.environment.get('tweetSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of tweet dto\\'s',",
											"    items: { $ref: tweetSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const content = pm.response.json().map(tweet => tweet.content)",
											"    const authors = pm.response.json().map(tweet => tweet.author.username)",
											"    ",
											"    pm.test('Author is correct', () => {",
											"        pm.expect(authors).to.include(pm.environment.get('firstUser'))",
											"    })",
											"    ",
											"    pm.test('Tweet content is correct', () => {",
											"        pm.expect(content).to.include(pm.environment.get('firstUserReply'))",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tweets/{{secondTweetId}}/replies",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{secondTweetId}}",
										"replies"
									]
								},
								"description": "Retrieves the direct replies to the tweet with the given id. if that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a response.\n\nDeleted replies to the tweet should be excluded from the resonse.\n\nResponse:\n[\n  {\n    \"id\": {id},\n    \"content\": \"{context}\",\n    \"posted\": {postedDate}\n    \"author\": {\n      \"username\": \"{username}\",\n      \"joined\": {joinedDate},\n      \"profile\": {\n        \"email\": \"{email}\",\n        \"firstName\": \"{firstname}\",\n        \"lastName\": \"{lastname}\",\n        \"phone\": \"{phoneNumber}\"\n      }\n    },\n  }\n]"
							},
							"response": []
						}
					],
					"description": "Tests for replying to tweets and getting replies to tweets."
				},
				{
					"name": "Repost Tweets",
					"item": [
						{
							"name": "FirstUser Retweet SecondUserTweet",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('tweetSchema')\r",
											"\r",
											"pm.test('Status success', () => {\r",
											"    pm.response.to.be.success\r",
											"})\r",
											"\r",
											"pm.test('Schema is valid', () => {\r",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true\r",
											"})\r",
											"\r",
											"if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {\r",
											"    const content = pm.response.json().map(tweet => tweet.content)\r",
											"    const authors = pm.response.json().map(tweet => tweet.author.username)\r",
											"    \r",
											"    pm.test('Contains the firstUser\\'s repost', () => {\r",
											"        pm.expect(content).to.include(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)\r",
											"        pm.expect(authors).to.include(pm.environment.get('firstUser'))\r",
											"    })\r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"username\": \"{{firstUser}}\",\n  \"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/tweets/{{secondTweetId}}/repost",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{secondTweetId}}",
										"repost"
									]
								},
								"description": "Creates a repost of the tweet with the given id. The author of the repost should match the credentials provided in the request body. If the given tweet is deleted or otherwise doesn't exist, or the given credentials do not match an active user in the database, an error should be sent in lieu of a response.\n\nBecause this creates a repost tweet, content is not allowed. Additionally, notice that the repostOf property is not provided by the request. The server must create that relationship.\n\nThe response should contain the newly-created tweet.\n\nRequest:\n{\n\t\"username\": \"{username}\",\n\t\"password\": \"{password}\"\n}\n\nResponse:\n{\n  \"id\": {id},\n  \"content\": \"{content}\",\n  \"posted\": {postedDate}\n  \"author\": {\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n      \"email\": \"{email}\",\n      \"firstName\": \"{firstname}\",\n      \"lastName\": \"{lastname}\",\n      \"phone\": \"{phoneNumber}\"\n    }\n  }\n}"
							},
							"response": []
						},
						{
							"name": "Get SecondTweet Reposts",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const tweetSchema = pm.environment.get('tweetSchema')",
											"",
											"const schema = {",
											"    type: 'array',",
											"    description: 'An array of tweet dto\\'s',",
											"    items: { $ref: tweetSchema }",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {",
											"    const content = pm.response.json().map(tweet => tweet.repostOf.content)",
											"    const authors = pm.response.json().map(tweet => tweet.author.username)",
											"    ",
											"    pm.test('Contains the firstUser\\'s repost', () => {",
											"        pm.expect(content).to.include(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)",
											"        pm.expect(authors).to.include(pm.environment.get('firstUser'))",
											"    })",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tweets/{{secondTweetId}}/reposts",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{secondTweetId}}",
										"reposts"
									]
								},
								"description": "Retrieves the direct reposts of the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a response.\n\nDeleted reposts of the tweet should be excluded from the response.\n\nResponse:\n[\n  {\n    \"id\": {id},\n    \"content\": \"{context}\",\n    \"posted\": {postedDate}\n    \"author\": {\n      \"username\": \"{username}\",\n      \"joined\": {joinedDate},\n      \"profile\": {\n        \"email\": \"{email}\",\n        \"firstName\": \"{firstname}\",\n        \"lastName\": \"{lastname}\",\n        \"phone\": \"{phoneNumber}\"\n      }\n    },\n  }\n]"
							},
							"response": []
						}
					],
					"description": "Tests for reposting and getting resposts of tweets."
				},
				{
					"name": "Tweet Context",
					"item": [
						{
							"name": "Get FirstUserReply Context",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const tweetSchema = pm.environment.get('tweetSchema')",
											"",
											"const schema = {",
											"    type: 'object',",
											"    description: 'A context dto',",
											"    properties: {",
											"        target: {",
											"            type: 'object',",
											"            $ref: tweetSchema ",
											"        },",
											"        before: {",
											"            type: 'array',",
											"            items: { $ref: tweetSchema } ",
											"        },",
											"        after: {",
											"            type: 'array',",
											"            items: { $ref: tweetSchema } ",
											"        }",
											"    },",
											"    required: ['target', 'before', 'after'],",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"const target = pm.response.json().target",
											"    ",
											"pm.test('Target id is correct', () => {",
											"    const id = target.id",
											"    pm.expect(id).to.not.eql(null)",
											"    pm.expect(id).to.eql(pm.environment.get('firstUserReplyId'))",
											"})",
											"    ",
											"pm.test('Target author is correct', () => {",
											"    const author = target.author",
											"    pm.expect(author.username).to.eql(pm.environment.get(\"firstUser\"))",
											"    pm.expect(new Date(author.joined)).to.eql(new Date(pm.environment.get(\"firstUserJoined\")))",
											"    const profile = author.profile",
											"    pm.expect(profile.firstName).to.eql(pm.environment.get(\"firstUserFirstName\"))",
											"    pm.expect(profile.lastName).to.eql(pm.environment.get(\"firstUserLastName\"))",
											"    pm.expect(profile.email).to.eql(pm.environment.get(\"firstUserEmail\"))",
											"    pm.expect(profile.phone).to.eql(pm.environment.get(\"firstUserPhone\"))",
											"})",
											"    ",
											"pm.test('Target date posted is not null', () => {",
											"    pm.expect(target.posted).to.not.eql(null)",
											"})",
											"   ",
											"    ",
											"pm.test('Target content is correct', () => {",
											"    pm.expect(target.content).to.eql(pm.environment.get('firstUserReply'))",
											"})",
											"",
											"pm.test('Before is correct', () => {",
											"    const before = pm.response.json().before",
											"    pm.expect(Array.isArray(before)).to.be.true",
											"    pm.expect(before.length).to.eql(1)",
											"    ",
											"    const authors = before.map(tweet => tweet.author.username)",
											"    pm.expect(authors).to.include(pm.environment.get('secondUser'))",
											"    ",
											"    const content = before.map(tweet => tweet.content)",
											"    pm.expect(content).to.include(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)",
											"})",
											"",
											"pm.test('After is correct', () => {",
											"    const after = pm.response.json().after",
											"    pm.expect(Array.isArray(after)).to.be.true",
											"    pm.expect(after.length).to.eql(0)",
											"})",
											"",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tweets/{{firstUserReplyId}}/context",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{firstUserReplyId}}",
										"context"
									]
								},
								"description": "Retrieves the context of the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a response.\n\nIMPORTANT: While deleted tweets should not be included in the before and after properties of the result, transitive replies should. What that means is that if a reply to the target of the context is deleted, but there's another reply to the deleted reply, the deleted reply should be excluded but the other reply should remain.\n\nResponse:\n{\n  \"after\": [{\n      \"id\": {id},\n      \"content\": \"{context}\",\n      \"posted\": {postedDate}\n      \"author\": {\n        \"username\": \"{username}\",\n        \"joined\": {joinedDate},\n        \"profile\": {\n          \"email\": \"{email}\",\n          \"firstName\": \"{firstname}\",\n          \"lastName\": \"{lastname}\",\n          \"phone\": \"{phoneNumber}\"\n        }\n      },\n    }\n  ],\n  \"before\": [\n    {\n      \"id\": {id},\n      \"content\": \"{context}\",\n      \"posted\": {postedDate}\n      \"author\": {\n        \"username\": \"{username}\",\n        \"joined\": {joinedDate},\n        \"profile\": {\n          \"email\": \"{email}\",\n          \"firstName\": \"{firstname}\",\n          \"lastName\": \"{lastname}\",\n          \"phone\": \"{phoneNumber}\"\n        }\n      },\n    }\n  ],\n  \"target\": {\n      \"id\": {id},\n      \"content\": \"{context}\",\n      \"posted\": {postedDate}\n      \"author\": {\n        \"username\": \"{username}\",\n        \"joined\": {joinedDate},\n        \"profile\": {\n          \"email\": \"{email}\",\n          \"firstName\": \"{firstname}\",\n          \"lastName\": \"{lastname}\",\n          \"phone\": \"{phoneNumber}\"\n        }\n      },\n    }\n}\n"
							},
							"response": []
						},
						{
							"name": "Get SecondTweet Context",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const tweetSchema = pm.environment.get('tweetSchema')",
											"",
											"const schema = {",
											"    type: 'object',",
											"    description: 'A context dto',",
											"    properties: {",
											"        target: {",
											"            type: 'object',",
											"            $ref: tweetSchema ",
											"        },",
											"        before: {",
											"            type: 'array',",
											"            items: { $ref: tweetSchema } ",
											"        },",
											"        after: {",
											"            type: 'array',",
											"            items: { $ref: tweetSchema } ",
											"        }",
											"    },",
											"    required: ['target', 'before', 'after'],",
											"}",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"    ",
											"pm.test('Target id is correct', () => {",
											"    const target = pm.response.json().target",
											"    const id = target.id",
											"    pm.expect(id).to.not.eql(null)",
											"    pm.expect(id).to.eql(pm.environment.get('secondTweetId'))",
											"})",
											"    ",
											"pm.test('Target author is correct', () => {",
											"    const target = pm.response.json().target",
											"    const author = target.author",
											"    pm.expect(author.username).to.eql(pm.environment.get(\"secondUser\"))",
											"    pm.expect(new Date(author.joined)).to.eql(new Date(pm.environment.get(\"secondUserJoined\")))",
											"    const profile = author.profile",
											"    pm.expect(profile.firstName).to.eql(pm.environment.get(\"secondUserFirstName\"))",
											"    pm.expect(profile.lastName).to.eql(pm.environment.get(\"secondUserLastName\"))",
											"    pm.expect(profile.email).to.eql(pm.environment.get(\"secondUserEmail\"))",
											"    pm.expect(profile.phone).to.eql(pm.environment.get(\"secondUserPhone\"))",
											"})",
											"    ",
											"pm.test('Target date posted is not null', () => {",
											"    const target = pm.response.json().target",
											"    pm.expect(target.posted).to.not.eql(null)",
											"})",
											"   ",
											"    ",
											"pm.test('Target content is correct', () => {",
											"    const target = pm.response.json().target",
											"    pm.expect(target.content).to.eql(`Tweet from the second user! @${pm.environment.get(\"firstUser\")} #${pm.environment.get(\"secondTag\")}`)",
											"})",
											"",
											"pm.test('Before is correct', () => {",
											"    const before = pm.response.json().before",
											"    pm.expect(Array.isArray(before)).to.be.true",
											"    pm.expect(before.length).to.eql(0)",
											"})",
											"",
											"pm.test('After is correct', () => {",
											"    const after = pm.response.json().after",
											"    pm.expect(Array.isArray(after)).to.be.true",
											"    pm.expect(after.length).to.eql(1)",
											"    ",
											"    const authors = after.map(tweet => tweet.author.username)",
											"    pm.expect(authors).to.include(pm.environment.get('firstUser'))",
											"    ",
											"    const content = after.map(tweet => tweet.content)",
											"    pm.expect(content).to.include(pm.environment.get('firstUserReply'))",
											"})",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tweets/{{secondTweetId}}/context",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{secondTweetId}}",
										"context"
									]
								},
								"description": "Retrieves the context of the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a response.\n\nIMPORTANT: While deleted tweets should not be included in the before and after properties of the result, transitive replies should. What that means is that if a reply to the target of the context is deleted, but there's another reply to the deleted reply, the deleted reply should be excluded but the other reply should remain.\n\nResponse:\n{\n  \"after\": [{\n      \"id\": {id},\n      \"content\": \"{context}\",\n      \"posted\": {postedDate}\n      \"author\": {\n        \"username\": \"{username}\",\n        \"joined\": {joinedDate},\n        \"profile\": {\n          \"email\": \"{email}\",\n          \"firstName\": \"{firstname}\",\n          \"lastName\": \"{lastname}\",\n          \"phone\": \"{phoneNumber}\"\n        }\n      },\n    }\n  ],\n  \"before\": [\n    {\n      \"id\": {id},\n      \"content\": \"{context}\",\n      \"posted\": {postedDate}\n      \"author\": {\n        \"username\": \"{username}\",\n        \"joined\": {joinedDate},\n        \"profile\": {\n          \"email\": \"{email}\",\n          \"firstName\": \"{firstname}\",\n          \"lastName\": \"{lastname}\",\n          \"phone\": \"{phoneNumber}\"\n        }\n      },\n    }\n  ],\n  \"target\": {\n      \"id\": {id},\n      \"content\": \"{context}\",\n      \"posted\": {postedDate}\n      \"author\": {\n        \"username\": \"{username}\",\n        \"joined\": {joinedDate},\n        \"profile\": {\n          \"email\": \"{email}\",\n          \"firstName\": \"{firstname}\",\n          \"lastName\": \"{lastname}\",\n          \"phone\": \"{phoneNumber}\"\n        }\n      },\n    }\n}\n"
							},
							"response": []
						}
					],
					"description": "Tests for the context endpoint of tweets."
				},
				{
					"name": "Delete Tweet",
					"item": [
						{
							"name": "Delete RandomTweet",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status not success', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n\t\"username\": \"{{firstUser}}\",\n\t\"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/tweets/randomTweet",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"randomTweet"
									]
								},
								"description": "\"Deletes\" the tweet with the given id. If no such tweet exists or the provided credentials do not match author of the tweet, an error should be sent in lieu of a response. If a tweet is successfully \"deleted\", the response should contain the tweet data prior to deletion.\n\nIMPORTANT: This action should not actually drop any records from the database! Instead, develop a way to keep track of \"deleted\" tweets so that even if a tweet is deleted, data with relationships to it (like replies and reposts) are still intact.\n\nRequest:\n{\n  \"username\": \"{username}\",\n  \"password\": \"{password}\"\n}\n\nResponse:\n{\n  \"id\": {id},\n  \"content\": \"{content}\",\n  \"posted\": {postedDate}\n  \"author\": {\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n      \"email\": \"{email}\",\n      \"firstName\": \"{firstname}\",\n      \"lastName\": \"{lastname}\",\n      \"phone\": \"{phoneNumber}\"\n    }\n  }\n}"
							},
							"response": []
						},
						{
							"name": "Delete FirstTweet",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('tweetSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Author should be the firstUser', () => {",
											"    pm.expect(pm.response.json().author.username).to.eql(pm.environment.get('firstUser'))",
											"})",
											"",
											"pm.test('Content should be the firstTweet', () => {",
											"     pm.expect(pm.response.json().content).to.eql(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n\t\"username\": \"{{firstUser}}\",\n\t\"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/tweets/{{firstTweetId}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{firstTweetId}}"
									]
								},
								"description": "\"Deletes\" the tweet with the given id. If no such tweet exists or the provided credentials do not match author of the tweet, an error should be sent in lieu of a response. If a tweet is successfully \"deleted\", the response should contain the tweet data prior to deletion.\n\nIMPORTANT: This action should not actually drop any records from the database! Instead, develop a way to keep track of \"deleted\" tweets so that even if a tweet is deleted, data with relationships to it (like replies and reposts) are still intact.\n\nRequest:\n{\n  \"username\": \"{username}\",\n  \"password\": \"{password}\"\n}\n\nResponse:\n{\n  \"id\": {id},\n  \"content\": \"{content}\",\n  \"posted\": {postedDate}\n  \"author\": {\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n      \"email\": \"{email}\",\n      \"firstName\": \"{firstname}\",\n      \"lastName\": \"{lastname}\",\n      \"phone\": \"{phoneNumber}\"\n    }\n  }\n}"
							},
							"response": []
						},
						{
							"name": "Delete SecondTweet",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('tweetSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Author should be the secondUser', () => {",
											"    pm.expect(pm.response.json().author.username).to.eql(pm.environment.get('secondUser'))",
											"})",
											"",
											"pm.test('Content should be the secondTweet', () => {",
											"     pm.expect(pm.response.json().content).to.eql(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"username\": \"{{secondUser}}\",\n    \"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/tweets/{{secondTweetId}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{secondTweetId}}"
									]
								},
								"description": "\"Deletes\" the tweet with the given id. If no such tweet exists or the provided credentials do not match author of the tweet, an error should be sent in lieu of a response. If a tweet is successfully \"deleted\", the response should contain the tweet data prior to deletion.\n\nIMPORTANT: This action should not actually drop any records from the database! Instead, develop a way to keep track of \"deleted\" tweets so that even if a tweet is deleted, data with relationships to it (like replies and reposts) are still intact.\n\nRequest:\n{\n\t\"username\": \"{username}\",\n\t\"password\": \"{password}\"\n}\n\nResponse:\n{\n  \"id\": {id},\n  \"content\": \"{content}\",\n  \"posted\": {postedDate}\n  \"author\": {\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n      \"email\": \"{email}\",\n      \"firstName\": \"{firstname}\",\n      \"lastName\": \"{lastname}\",\n      \"phone\": \"{phoneNumber}\"\n    }\n  }\n}"
							},
							"response": []
						},
						{
							"name": "Delete SecondTweet Again",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status not success', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n\t\"username\": \"{{secondUser}}\",\n\t\"password\": \"{{password}}\"\n}"
								},
								"url": {
									"raw": "localhost:8080/tweets/{{secondTweetId}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{secondTweetId}}"
									]
								},
								"description": "\"Deletes\" the tweet with the given id. If no such tweet exists or the provided credentials do not match author of the tweet, an error should be sent in lieu of a response. If a tweet is successfully \"deleted\", the response should contain the tweet data prior to deletion.\n\nIMPORTANT: This action should not actually drop any records from the database! Instead, develop a way to keep track of \"deleted\" tweets so that even if a tweet is deleted, data with relationships to it (like replies and reposts) are still intact.\n\nRequest:\n{\n  \"username\": \"{username}\",\n  \"password\": \"{password}\"\n}\n\nResponse:\n{\n  \"id\": {id},\n  \"content\": \"{content}\",\n  \"posted\": {postedDate}\n  \"author\": {\n    \"username\": \"{username}\",\n    \"joined\": {joinedDate},\n    \"profile\": {\n      \"email\": \"{email}\",\n      \"firstName\": \"{firstname}\",\n      \"lastName\": \"{lastname}\",\n      \"phone\": \"{phoneNumber}\"\n    }\n  }\n}"
							},
							"response": []
						},
						{
							"name": "Get SecondTweet Context After Delete",
							"event": [
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"pm.test('Status not success', () => {",
											"    pm.response.to.not.be.success",
											"    pm.response.to.not.be.info",
											"})",
											"",
											"pm.test('Should not be an internal server error', () => {",
											"    pm.response.to.not.be.serverError",
											"})"
										]
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/tweets/{{secondTweetId}}/context",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"tweets",
										"{{secondTweetId}}",
										"context"
									]
								},
								"description": "Retrieves the context of the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a response.\n\nIMPORTANT: While deleted tweets should not be included in the before and after properties of the result, transitive replies should. What that means is that if a reply to the target of the context is deleted, but there's another reply to the deleted reply, the deleted reply should be excluded but the other reply should remain.\n\nResponse:\n{\n  \"after\": [{\n      \"id\": {id},\n      \"content\": \"{context}\",\n      \"posted\": {postedDate}\n      \"author\": {\n        \"username\": \"{username}\",\n        \"joined\": {joinedDate},\n        \"profile\": {\n          \"email\": \"{email}\",\n          \"firstName\": \"{firstname}\",\n          \"lastName\": \"{lastname}\",\n          \"phone\": \"{phoneNumber}\"\n        }\n      },\n    }\n  ],\n  \"before\": [\n    {\n      \"id\": {id},\n      \"content\": \"{context}\",\n      \"posted\": {postedDate}\n      \"author\": {\n        \"username\": \"{username}\",\n        \"joined\": {joinedDate},\n        \"profile\": {\n          \"email\": \"{email}\",\n          \"firstName\": \"{firstname}\",\n          \"lastName\": \"{lastname}\",\n          \"phone\": \"{phoneNumber}\"\n        }\n      },\n    }\n  ],\n  \"target\": {\n      \"id\": {id},\n      \"content\": \"{context}\",\n      \"posted\": {postedDate}\n      \"author\": {\n        \"username\": \"{username}\",\n        \"joined\": {joinedDate},\n        \"profile\": {\n          \"email\": \"{email}\",\n          \"firstName\": \"{firstname}\",\n          \"lastName\": \"{lastname}\",\n          \"phone\": \"{phoneNumber}\"\n        }\n      },\n    }\n}\n"
							},
							"response": []
						}
					],
					"description": "Tests for deleting tweets."
				}
			]
		},
		{
			"name": "Hashtag",
			"item": [
				{
					"name": "Get All Tags",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const hashtagSchema = pm.environment.get('hashtagSchema')",
									"",
									"const schema = {",
									"    type: 'array',",
									"    description: 'An array of hashtag dto\\'s',",
									"    items: { $ref: hashtagSchema }",
									"}",
									"",
									"pm.test('Status success', () => {",
									"    pm.response.to.be.success",
									"})",
									"",
									"pm.test('Schema is valid', () => {",
									"  pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
									"})",
									"",
									"pm.test('Should contain two values', () => {",
									"    pm.expect(pm.response.json().length).to.eql(2)",
									"})",
									"",
									"pm.test('Should contain the first and second hashtag', () => {",
									"    const hashtags = pm.response.json().map(hashtag => hashtag.label)",
									"    pm.expect(hashtags).to.include(pm.environment.get('firstTag'))",
									"    pm.expect(hashtags).to.include(pm.environment.get('secondTag'))",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "localhost:8080/tags",
							"host": [
								"localhost"
							],
							"port": "8080",
							"path": [
								"tags"
							]
						},
						"description": "Retrieves all hashtags tracked by the database.\n\nResponse:\n[\n  {\n    \"firstUsed\": {firstUsedDate},\n    \"label\": \"{label}\",\n    \"lastUsed\": {lastUsedDate}\n  }\n]"
					},
					"response": []
				},
				{
					"name": "Get RandomTag",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"pm.test('Status error', () => {",
									"    pm.response.to.not.be.success",
									"    pm.response.to.not.be.info",
									"})",
									"",
									"pm.test('Should not be internal server error', () => {",
									"    pm.response.to.not.be.serverError",
									"})"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "localhost:8080/tags/randomTag",
							"host": [
								"localhost"
							],
							"port": "8080",
							"path": [
								"tags",
								"randomTag"
							]
						},
						"description": "Retrieves all (non-deleted) tweets tagged with the given hashtag label. The tweets should appear in reverse-chronological order. If no hashtag with the given label exists, an error should be sent in lieu of a response.\n\nA tweet is considered \"tagged\" by a hashtag if the tweet has content and the hashtag's label appears in that content following a #.\n\nResponse:\n[\n  {\n    \"id\": {id},\n    \"content\": \"{content}\",\n    \"posted\": {postedDate}\n    \"author\": {\n      \"username\": \"{username}\",\n      \"joined\": {joinedDate},\n      \"profile\": {\n        \"email\": \"{email}\",\n        \"firstName\": \"{firstname}\",\n        \"lastName\": \"{lastname}\",\n        \"phone\": \"{phoneNumber}\"\n      }\n    }\n  }\n]"
					},
					"response": []
				}
			]
		},
		{
			"name": "Validate",
			"item": [
				{
					"name": "Tag Validation",
					"item": [
						{
							"name": "RandomTag Exists",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('booleanSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"    pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"",
											"pm.test('Should return a boolean', () => {",
											"    pm.expect(typeof(pm.response.json())).to.eql('boolean')",
											"})",
											"",
											"pm.test('Should return false', () => {",
											"    pm.expect(pm.response.json()).to.be.false",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/validate/tag/exists/randomTag",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"validate",
										"tag",
										"exists",
										"randomTag"
									]
								},
								"description": "Initially the \"firstTag\" environment variable should not exist in the student's database.\n\nExpected Status: success\nExpected Response Body: false"
							},
							"response": []
						},
						{
							"name": "FirstTag Exists",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('booleanSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.have.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"    pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('FirstTag should exist', () => {",
											"    pm.expect(pm.response.json()).to.be.true",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/validate/tag/exists/{{firstTag}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"validate",
										"tag",
										"exists",
										"{{firstTag}}"
									]
								},
								"description": "Now that the firstTag has been created in the firstUser's tweet, we need to verify it exists. Should return true and a success status.\n\nExpected Status: success\nExpected Response Body: true"
							},
							"response": []
						},
						{
							"name": "SecondTag Exists",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('booleanSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.have.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"    pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('SecondTag should exist', () => {",
											"    pm.expect(pm.response.json()).to.be.true",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/validate/tag/exists/{{secondTag}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"validate",
										"tag",
										"exists",
										"{{secondTag}}"
									]
								},
								"description": "Now that the secondTag has been created in the secondUser's tweet, we need to verify it exists. Should return true and a success status.\n\nExpected Status: success\nExpected Response Body: true"
							},
							"response": []
						}
					],
					"description": "Tests for the /tag validation endpoint."
				},
				{
					"name": "User Validation",
					"item": [
						{
							"name": "RandomUser Available",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('booleanSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"    pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"",
											"pm.test('Should return a boolean', () => {",
											"    pm.expect(typeof(pm.response.json())).to.eql('boolean')",
											"})",
											"",
											"pm.test('Should return true', () => {",
											"    pm.expect(pm.response.json()).to.be.true",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/validate/username/available/@randomUser",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"validate",
										"username",
										"available",
										"@randomUser"
									]
								},
								"description": "Validates that the /username/available/@{username} endpoint is in the correct format."
							},
							"response": []
						},
						{
							"name": "RandomUser Exists",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('booleanSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"    pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"",
											"pm.test('Should return a boolean', () => {",
											"    pm.expect(typeof(pm.response.json())).to.eql('boolean')",
											"})",
											"",
											"pm.test('Should return false', () => {",
											"    pm.expect(pm.response.json()).to.be.false",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"url": {
									"raw": "localhost:8080/validate/username/exists/@randomUser",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"validate",
										"username",
										"exists",
										"@randomUser"
									]
								},
								"description": "Validates that the /username/exists/@{username} endpoint is in the correct format."
							},
							"response": []
						},
						{
							"name": "FirstUser Available After Creation",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('booleanSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"    pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Should return a boolean', () => {",
											"    pm.expect(typeof(pm.response.json())).to.eql('boolean')",
											"})",
											"",
											"pm.test('FirstUser should not be available', () => {",
											"    pm.expect(pm.response.json()).to.be.false",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/validate/username/available/@{{firstUser}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"validate",
										"username",
										"available",
										"@{{firstUser}}"
									]
								},
								"description": "Validates that the /username/available/@{username} endpoint is in the correct format."
							},
							"response": []
						},
						{
							"name": "FirstUser Exists After Creation",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('booleanSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"    pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Should return a boolean', () => {",
											"    pm.expect(typeof(pm.response.json())).to.eql('boolean')",
											"})",
											"",
											"pm.test('FirstUser should exist', () => {",
											"    pm.expect(pm.response.json()).to.be.true",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/validate/username/exists/@{{firstUser}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"validate",
										"username",
										"exists",
										"@{{firstUser}}"
									]
								},
								"description": "Validates that the /username/available/@{username} endpoint is in the correct format."
							},
							"response": []
						},
						{
							"name": "SecondUser Available After Creation",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('booleanSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"    pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Should return a boolean', () => {",
											"    pm.expect(typeof(pm.response.json())).to.eql('boolean')",
											"})",
											"",
											"pm.test('SecondUser should not be available', () => {",
											"    pm.expect(pm.response.json()).to.be.false",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/validate/username/available/@{{secondUser}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"validate",
										"username",
										"available",
										"@{{secondUser}}"
									]
								},
								"description": "Validates that the /username/available/@{username} endpoint is in the correct format."
							},
							"response": []
						},
						{
							"name": "SecondUser Exists After Creation",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const schema = pm.environment.get('booleanSchema')",
											"",
											"pm.test('Status success', () => {",
											"    pm.response.to.be.success",
											"})",
											"",
											"pm.test('Schema is valid', () => {",
											"    pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true",
											"})",
											"",
											"pm.test('Should return a boolean', () => {",
											"    pm.expect(typeof(pm.response.json())).to.eql('boolean')",
											"})",
											"",
											"pm.test('SecondUser should exist', () => {",
											"    pm.expect(pm.response.json()).to.be.true",
											"})"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "localhost:8080/validate/username/exists/@{{secondUser}}",
									"host": [
										"localhost"
									],
									"port": "8080",
									"path": [
										"validate",
										"username",
										"exists",
										"@{{secondUser}}"
									]
								},
								"description": "Validates that the /username/available/@{username} endpoint is in the correct format."
							},
							"response": []
						}
					],
					"description": "Test for the /username validation endpoint."
				}
			],
			"description": "requests for the validate endpoint."
		}
	]
}